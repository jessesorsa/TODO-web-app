import {
  DEV
} from "./chunk-IP2U24VQ.js";
import {
  EMPTY_FUNC,
  run_all,
  subscribe_to_store
} from "./chunk-F3TNGEWF.js";

// node_modules/svelte/src/internal/client/utils.js
var is_array = Array.isArray;
var array_from = Array.from;
var object_keys = Object.keys;
var object_assign = Object.assign;
var is_frozen = Object.isFrozen;
var object_freeze = Object.freeze;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
function is_function(thing) {
  return typeof thing === "function";
}

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_KEYED = 1 << 2;
var EACH_PROXIED = 1 << 3;
var EACH_IS_CONTROLLED = 1 << 3;
var EACH_IS_ANIMATED = 1 << 4;
var EACH_IS_IMMUTABLE = 1 << 6;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_LAZY_INITIAL = 1 << 3;
var DelegatedEvents = [
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  // 'input', This conflicts with bind:input
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
var PassiveDelegatedEvents = ["touchstart", "touchmove", "touchend"];
var AttributeAliases = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly"
};
var DOMBooleanAttributes = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];

// node_modules/svelte/src/internal/client/proxy/readonly.js
function readonly(value) {
  const proxy2 = value && value[READONLY_SYMBOL];
  if (proxy2)
    return proxy2;
  if (typeof value === "object" && value != null && !is_frozen(value) && STATE_SYMBOL in value && // TODO handle Map and Set as well
  !(READONLY_SYMBOL in value)) {
    const proxy3 = new Proxy(value, handler);
    define_property(value, READONLY_SYMBOL, { value: proxy3, writable: false });
    return proxy3;
  }
  return value;
}
var readonly_error = (_, prop2) => {
  throw new Error(
    `Non-bound props cannot be mutated â€” to make the \`${prop2}\` settable, ensure the object it is used within is bound as a prop \`bind:<prop>={...}\`. Fallback values can never be mutated.`
  );
};
var handler = {
  defineProperty: readonly_error,
  deleteProperty: readonly_error,
  set: readonly_error,
  get(target, prop2, receiver) {
    const value = Reflect.get(target, prop2, receiver);
    if (!(prop2 in target)) {
      return readonly(value);
    }
    return value;
  }
};

// node_modules/svelte/src/internal/client/block.js
var ROOT_BLOCK = 0;
var IF_BLOCK = 1;
var EACH_BLOCK = 2;
var EACH_ITEM_BLOCK = 3;
var AWAIT_BLOCK = 4;
var KEY_BLOCK = 5;
var HEAD_BLOCK = 6;
var DYNAMIC_COMPONENT_BLOCK = 7;
var DYNAMIC_ELEMENT_BLOCK = 8;
var SNIPPET_BLOCK = 9;
function create_root_block(intro) {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // intro
    i: intro,
    // parent
    p: null,
    // transition
    r: null,
    // type
    t: ROOT_BLOCK
  };
}
function create_if_block() {
  return {
    // alternate transitions
    a: null,
    // alternate effect
    ae: null,
    // consequent transitions
    c: null,
    // consequent effect
    ce: null,
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: IF_BLOCK,
    // value
    v: false
  };
}
function create_key_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: KEY_BLOCK
  };
}
function create_head_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: HEAD_BLOCK
  };
}
function create_dynamic_element_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: DYNAMIC_ELEMENT_BLOCK
  };
}
function create_dynamic_component_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // type
    t: DYNAMIC_COMPONENT_BLOCK
  };
}
function create_await_block() {
  return {
    // dom
    d: null,
    // effect
    e: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // pending
    n: true,
    // transition
    r: null,
    // type
    t: AWAIT_BLOCK
  };
}
function create_each_block(flags, anchor) {
  return {
    // anchor
    a: anchor,
    // dom
    d: null,
    // flags
    f: flags,
    // items
    v: [],
    // effect
    e: null,
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // transition
    r: null,
    // transitions
    s: [],
    // type
    t: EACH_BLOCK
  };
}
function create_each_item_block(item, index, key) {
  return {
    // animate transition
    a: null,
    // dom
    d: null,
    // effect
    e: null,
    // index
    i: index,
    // key
    k: key,
    // item
    v: item,
    // parent
    p: (
      /** @type {import('./types.js').EachBlock} */
      current_block
    ),
    // transition
    r: null,
    // transitions
    s: null,
    // type
    t: EACH_ITEM_BLOCK
  };
}
function create_snippet_block() {
  return {
    // dom
    d: null,
    // parent
    p: (
      /** @type {import('./types.js').Block} */
      current_block
    ),
    // effect
    e: null,
    // transition
    r: null,
    // type
    t: SNIPPET_BLOCK
  };
}

// node_modules/svelte/src/internal/client/runtime.js
var SOURCE = 1;
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var PRE_EFFECT = 1 << 3;
var RENDER_EFFECT = 1 << 4;
var MANAGED = 1 << 6;
var UNOWNED = 1 << 7;
var CLEAN = 1 << 8;
var DIRTY = 1 << 9;
var MAYBE_DIRTY = 1 << 10;
var INERT = 1 << 11;
var DESTROYED = 1 << 12;
var IS_EFFECT = EFFECT | PRE_EFFECT | RENDER_EFFECT;
var FLUSH_MICROTASK = 0;
var FLUSH_SYNC = 1;
var UNINITIALIZED = Symbol();
var LAZY_PROPERTY = Symbol();
var current_scheduler_mode = FLUSH_MICROTASK;
var is_micro_task_queued = false;
var is_task_queued = false;
var is_raf_queued = false;
var is_batching_effect = false;
var current_queued_pre_and_render_effects = [];
var current_queued_effects = [];
var current_queued_tasks = [];
var current_raf_tasks = [];
var flush_count = 0;
var current_consumer = null;
var current_effect = null;
var current_dependencies = null;
var current_dependencies_index = 0;
var current_untracked_writes = null;
var last_inspected_signal = null;
var current_untracking = false;
var ignore_mutation_validation = false;
var current_skip_consumer = false;
var is_signals_recorded = false;
var captured_signals = /* @__PURE__ */ new Set();
var inspect_fn = null;
var inspect_captured_signals = [];
var current_block = null;
var current_component_context = null;
var is_ssr = false;
var updating_derived = false;
function set_is_ssr(ssr) {
  is_ssr = ssr;
}
function is_runes(context) {
  const component_context = context || current_component_context;
  return component_context !== null && component_context.r;
}
function batch_inspect(target, prop2, receiver) {
  const value = Reflect.get(target, prop2, receiver);
  return function() {
    const previously_batching_effect = is_batching_effect;
    is_batching_effect = true;
    try {
      return Reflect.apply(value, receiver, arguments);
    } finally {
      is_batching_effect = previously_batching_effect;
      if (last_inspected_signal !== null) {
        for (const fn of last_inspected_signal.inspect)
          fn();
        last_inspected_signal = null;
      }
    }
  };
}
function default_equals(a, b) {
  return a === b;
}
function create_source_signal(flags, value) {
  if (DEV) {
    return {
      // consumers
      c: null,
      // equals
      e: default_equals,
      // flags
      f: flags,
      // value
      v: value,
      // context: We can remove this if we get rid of beforeUpdate/afterUpdate
      x: null,
      // this is for DEV only
      inspect: /* @__PURE__ */ new Set()
    };
  }
  return {
    // consumers
    c: null,
    // equals
    e: default_equals,
    // flags
    f: flags,
    // value
    v: value,
    // context: We can remove this if we get rid of beforeUpdate/afterUpdate
    x: null
  };
}
function create_computation_signal(flags, value, block) {
  if (DEV) {
    return {
      // block
      b: block,
      // consumers
      c: null,
      // destroy
      d: null,
      // equals
      e: null,
      // flags
      f: flags,
      // init
      i: null,
      // level
      l: 0,
      // references
      r: null,
      // value
      v: value,
      // context: We can remove this if we get rid of beforeUpdate/afterUpdate
      x: null,
      // destroy
      y: null,
      // this is for DEV only
      inspect: /* @__PURE__ */ new Set()
    };
  }
  return {
    // block
    b: block,
    // consumers
    c: null,
    // destroy
    d: null,
    // equals
    e: null,
    // flags
    f: flags,
    // level
    l: 0,
    // init
    i: null,
    // references
    r: null,
    // value
    v: value,
    // context: We can remove this if we get rid of beforeUpdate/afterUpdate
    x: null,
    // destroy
    y: null
  };
}
function push_reference(target_signal, ref_signal) {
  const references = target_signal.r;
  if (references === null) {
    target_signal.r = [ref_signal];
  } else {
    references.push(ref_signal);
  }
}
function is_signal_dirty(signal) {
  const flags = signal.f;
  if ((flags & DIRTY) !== 0 || signal.v === UNINITIALIZED) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    const dependencies = (
      /** @type {import('./types.js').ComputationSignal<V>} **/
      signal.d
    );
    if (dependencies !== null) {
      const length = dependencies.length;
      let i;
      for (i = 0; i < length; i++) {
        const dependency = dependencies[i];
        if ((dependency.f & MAYBE_DIRTY) !== 0 && !is_signal_dirty(dependency)) {
          set_signal_status(dependency, CLEAN);
          continue;
        }
        if ((dependency.f & DIRTY) !== 0) {
          if ((dependency.f & DERIVED) !== 0) {
            update_derived(
              /** @type {import('./types.js').ComputationSignal<V>} **/
              dependency,
              true
            );
            if ((signal.f & DIRTY) !== 0) {
              return true;
            }
          } else {
            return true;
          }
        }
      }
    }
  }
  return false;
}
function execute_signal_fn(signal) {
  const init2 = signal.i;
  const previous_dependencies = current_dependencies;
  const previous_dependencies_index = current_dependencies_index;
  const previous_untracked_writes = current_untracked_writes;
  const previous_consumer = current_consumer;
  const previous_block = current_block;
  const previous_component_context = current_component_context;
  const previous_skip_consumer = current_skip_consumer;
  const is_render_effect = (signal.f & RENDER_EFFECT) !== 0;
  const previous_untracking = current_untracking;
  current_dependencies = /** @type {null | import('./types.js').Signal[]} */
  null;
  current_dependencies_index = 0;
  current_untracked_writes = null;
  current_consumer = signal;
  current_block = signal.b;
  current_component_context = signal.x;
  current_skip_consumer = current_effect === null && (signal.f & UNOWNED) !== 0;
  current_untracking = false;
  if (is_render_effect && (current_component_context == null ? void 0 : current_component_context.u) != null) {
    current_component_context.u.e();
  }
  try {
    let res;
    if (is_render_effect) {
      res = /** @type {(block: import('./types.js').Block, signal: import('./types.js').Signal) => V} */
      init2(
        /** @type {import('./types.js').Block} */
        signal.b,
        /** @type {import('./types.js').Signal} */
        signal
      );
    } else {
      res = /** @type {() => V} */
      init2();
    }
    let dependencies = (
      /** @type {import('./types.js').Signal<unknown>[]} **/
      signal.d
    );
    if (current_dependencies !== null) {
      let i;
      if (dependencies !== null) {
        const full_dependencies = current_dependencies_index === 0 ? dependencies : dependencies.slice(0, current_dependencies_index).concat(current_dependencies);
        const dep_length = full_dependencies.length;
        const current_dependencies_set = dep_length > 16 ? new Set(full_dependencies) : null;
        for (i = current_dependencies_index; i < dep_length; i++) {
          const dependency = full_dependencies[i];
          if (current_dependencies_set !== null && !current_dependencies_set.has(dependency) || !full_dependencies.includes(dependency)) {
            remove_consumer(signal, dependency, false);
          }
        }
      }
      if (dependencies !== null && current_dependencies_index > 0) {
        dependencies.length = current_dependencies_index + current_dependencies.length;
        for (i = 0; i < current_dependencies.length; i++) {
          dependencies[current_dependencies_index + i] = current_dependencies[i];
        }
      } else {
        signal.d = /** @type {import('./types.js').Signal<V>[]} **/
        dependencies = current_dependencies;
      }
      if (!current_skip_consumer) {
        for (i = current_dependencies_index; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          const consumers = dependency.c;
          if (consumers === null) {
            dependency.c = [signal];
          } else if (consumers[consumers.length - 1] !== signal) {
            consumers.push(signal);
          }
        }
      }
    } else if (dependencies !== null && current_dependencies_index < dependencies.length) {
      remove_consumers(signal, current_dependencies_index, false);
      dependencies.length = current_dependencies_index;
    }
    return res;
  } finally {
    current_dependencies = previous_dependencies;
    current_dependencies_index = previous_dependencies_index;
    current_untracked_writes = previous_untracked_writes;
    current_consumer = previous_consumer;
    current_block = previous_block;
    current_component_context = previous_component_context;
    current_skip_consumer = previous_skip_consumer;
    current_untracking = previous_untracking;
  }
}
function remove_consumer(signal, dependency, remove_unowned) {
  const consumers = dependency.c;
  let consumers_length = 0;
  if (consumers !== null) {
    consumers_length = consumers.length - 1;
    const index = consumers.indexOf(signal);
    if (index !== -1) {
      if (consumers_length === 0) {
        dependency.c = null;
      } else {
        consumers[index] = consumers[consumers_length];
        consumers.pop();
      }
    }
  }
  if (remove_unowned && consumers_length === 0 && (dependency.f & UNOWNED) !== 0) {
    set_signal_status(dependency, DIRTY);
    remove_consumers(
      /** @type {import('./types.js').ComputationSignal<V>} **/
      dependency,
      0,
      true
    );
  }
}
function remove_consumers(signal, start_index, remove_unowned) {
  const dependencies = signal.d;
  if (dependencies !== null) {
    const active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);
    let i;
    for (i = start_index; i < dependencies.length; i++) {
      const dependency = dependencies[i];
      if (active_dependencies === null || !active_dependencies.includes(dependency)) {
        remove_consumer(signal, dependency, remove_unowned);
      }
    }
  }
}
function destroy_references(signal) {
  const references = signal.r;
  signal.r = null;
  if (references !== null) {
    let i;
    for (i = 0; i < references.length; i++) {
      const reference = references[i];
      if ((reference.f & IS_EFFECT) !== 0) {
        destroy_signal(reference);
      } else {
        remove_consumers(reference, 0, true);
        reference.d = null;
      }
    }
  }
}
function report_error(block, error) {
  let current_block2 = block;
  if (current_block2 !== null) {
    throw error;
  }
}
function execute_effect(signal) {
  if ((signal.f & DESTROYED) !== 0) {
    return;
  }
  const teardown = signal.v;
  const previous_effect = current_effect;
  current_effect = signal;
  try {
    destroy_references(signal);
    if (teardown !== null) {
      teardown();
    }
    const possible_teardown = execute_signal_fn(signal);
    if (typeof possible_teardown === "function") {
      signal.v = possible_teardown;
    }
  } catch (error) {
    const block = signal.b;
    if (block !== null) {
      report_error(block, error);
    } else {
      throw error;
    }
  } finally {
    current_effect = previous_effect;
  }
  const component_context = signal.x;
  if (is_runes(component_context) && // Don't rerun pre effects more than once to accomodate for "$: only runs once" behavior
  (signal.f & PRE_EFFECT) !== 0 && current_queued_pre_and_render_effects.length > 0) {
    flush_local_pre_effects(component_context);
  }
}
function infinite_loop_guard() {
  if (flush_count > 100) {
    throw new Error(
      "ERR_SVELTE_TOO_MANY_UPDATES" + (DEV ? ": Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops." : "")
    );
  }
  flush_count++;
}
function flush_queued_effects(effects) {
  const length = effects.length;
  if (length > 0) {
    infinite_loop_guard();
    let i;
    for (i = 0; i < length; i++) {
      const signal = effects[i];
      const flags = signal.f;
      if ((flags & (DESTROYED | INERT)) === 0) {
        if (is_signal_dirty(signal)) {
          set_signal_status(signal, CLEAN);
          execute_effect(signal);
        } else if ((flags & MAYBE_DIRTY) !== 0) {
          set_signal_status(signal, CLEAN);
        }
      }
    }
    effects.length = 0;
  }
}
function process_microtask() {
  is_micro_task_queued = false;
  if (flush_count > 101) {
    return;
  }
  const previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;
  const previous_queued_effects = current_queued_effects;
  current_queued_pre_and_render_effects = [];
  current_queued_effects = [];
  flush_queued_effects(previous_queued_pre_and_render_effects);
  flush_queued_effects(previous_queued_effects);
  if (!is_micro_task_queued) {
    flush_count = 0;
  }
}
function schedule_effect(signal, sync) {
  const flags = signal.f;
  if (sync) {
    execute_effect(signal);
    set_signal_status(signal, CLEAN);
  } else {
    if (current_scheduler_mode === FLUSH_MICROTASK) {
      if (!is_micro_task_queued) {
        is_micro_task_queued = true;
        queueMicrotask(process_microtask);
      }
    }
    if ((flags & EFFECT) !== 0) {
      current_queued_effects.push(signal);
      if ((flags & MANAGED) === 0) {
        mark_subtree_children_inert(signal, true);
      }
    } else {
      const length = current_queued_pre_and_render_effects.length;
      let should_append = length === 0;
      if (!should_append) {
        const target_level = signal.l;
        const target_block = signal.b;
        const is_pre_effect = (flags & PRE_EFFECT) !== 0;
        let target_signal;
        let is_target_pre_effect;
        let i = length;
        while (true) {
          target_signal = current_queued_pre_and_render_effects[--i];
          if (target_signal.l <= target_level) {
            if (i + 1 === length) {
              should_append = true;
            } else {
              is_target_pre_effect = (target_signal.f & PRE_EFFECT) !== 0;
              if (target_signal.b !== target_block || is_target_pre_effect && !is_pre_effect) {
                i++;
              }
              current_queued_pre_and_render_effects.splice(i, 0, signal);
            }
            break;
          }
          if (i === 0) {
            current_queued_pre_and_render_effects.unshift(signal);
            break;
          }
        }
      }
      if (should_append) {
        current_queued_pre_and_render_effects.push(signal);
      }
    }
  }
}
function process_task() {
  is_task_queued = false;
  const tasks = current_queued_tasks.slice();
  current_queued_tasks = [];
  run_all(tasks);
}
function process_raf_task() {
  is_raf_queued = false;
  const tasks = current_raf_tasks.slice();
  current_raf_tasks = [];
  run_all(tasks);
}
function schedule_task(fn) {
  if (!is_task_queued) {
    is_task_queued = true;
    setTimeout(process_task, 0);
  }
  current_queued_tasks.push(fn);
}
function schedule_raf_task(fn) {
  if (!is_raf_queued) {
    is_raf_queued = true;
    requestAnimationFrame(process_raf_task);
  }
  current_raf_tasks.push(fn);
}
function flush_local_render_effects() {
  const effects = [];
  for (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {
    const effect2 = current_queued_pre_and_render_effects[i];
    if ((effect2.f & RENDER_EFFECT) !== 0 && effect2.x === current_component_context) {
      effects.push(effect2);
      current_queued_pre_and_render_effects.splice(i, 1);
      i--;
    }
  }
  flush_queued_effects(effects);
}
function flush_local_pre_effects(context) {
  const effects = [];
  for (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {
    const effect2 = current_queued_pre_and_render_effects[i];
    if ((effect2.f & PRE_EFFECT) !== 0 && effect2.x === context) {
      effects.push(effect2);
      current_queued_pre_and_render_effects.splice(i, 1);
      i--;
    }
  }
  flush_queued_effects(effects);
}
function flushSync(fn) {
  const previous_scheduler_mode = current_scheduler_mode;
  const previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;
  const previous_queued_effects = current_queued_effects;
  try {
    infinite_loop_guard();
    const pre_and_render_effects = [];
    const effects = [];
    current_scheduler_mode = FLUSH_SYNC;
    current_queued_pre_and_render_effects = pre_and_render_effects;
    current_queued_effects = effects;
    flush_queued_effects(previous_queued_pre_and_render_effects);
    flush_queued_effects(previous_queued_effects);
    if (fn !== void 0) {
      fn();
    }
    if (current_queued_pre_and_render_effects.length > 0 || effects.length > 0) {
      flushSync();
    }
    if (is_raf_queued) {
      process_raf_task();
    }
    if (is_task_queued) {
      process_task();
    }
    flush_count = 0;
  } finally {
    current_scheduler_mode = previous_scheduler_mode;
    current_queued_pre_and_render_effects = previous_queued_pre_and_render_effects;
    current_queued_effects = previous_queued_effects;
  }
}
async function tick() {
  await Promise.resolve();
  flushSync();
}
function update_derived(signal, force_schedule) {
  const previous_updating_derived = updating_derived;
  updating_derived = true;
  const value = execute_signal_fn(signal);
  updating_derived = previous_updating_derived;
  const status = current_skip_consumer || current_effect === null && (signal.f & UNOWNED) !== 0 ? DIRTY : CLEAN;
  set_signal_status(signal, status);
  const equals = (
    /** @type {import('./types.js').EqualsFunctions} */
    signal.e
  );
  if (!equals(value, signal.v)) {
    signal.v = value;
    mark_signal_consumers(signal, DIRTY, force_schedule);
    if (DEV && signal.inspect && force_schedule) {
      for (
        const fn of
        /** @type {import('./types.js').SignalDebug} */
        signal.inspect
      )
        fn();
    }
  }
}
function store_get(store, store_name, stores) {
  let entry = stores[store_name];
  const is_new = entry === void 0;
  if (is_new) {
    entry = {
      store: null,
      last_value: null,
      value: mutable_source(UNINITIALIZED),
      unsubscribe: EMPTY_FUNC
    };
    stores[store_name] = entry;
  }
  if (is_new || entry.store !== store) {
    entry.unsubscribe();
    entry.store = store ?? null;
    entry.unsubscribe = connect_store_to_signal(store, entry.value);
  }
  const value = get(entry.value);
  return value === UNINITIALIZED ? entry.last_value : value;
}
function connect_store_to_signal(store, source2) {
  if (store == null) {
    set(source2, void 0);
    return EMPTY_FUNC;
  }
  const run = (v) => {
    ignore_mutation_validation = true;
    set(source2, v);
    ignore_mutation_validation = false;
  };
  return subscribe_to_store(store, run);
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function unsubscribe_on_destroy(stores) {
  onDestroy(() => {
    let store_name;
    for (store_name in stores) {
      const ref = stores[store_name];
      ref.unsubscribe();
    }
  });
}
function get(signal) {
  if (DEV && signal.inspect && inspect_fn) {
    signal.inspect.add(inspect_fn);
    inspect_captured_signals.push(signal);
  }
  const flags = signal.f;
  if ((flags & DESTROYED) !== 0) {
    return signal.v;
  }
  if (is_signals_recorded) {
    captured_signals.add(signal);
  }
  if (current_consumer !== null && (current_consumer.f & MANAGED) === 0 && !current_untracking) {
    const unowned = (current_consumer.f & UNOWNED) !== 0;
    const dependencies = current_consumer.d;
    if (current_dependencies === null && dependencies !== null && dependencies[current_dependencies_index] === signal && !(unowned && current_effect !== null)) {
      current_dependencies_index++;
    } else if (dependencies === null || current_dependencies_index === 0 || dependencies[current_dependencies_index - 1] !== signal) {
      if (current_dependencies === null) {
        current_dependencies = [signal];
      } else if (signal !== current_dependencies[current_dependencies.length - 1]) {
        current_dependencies.push(signal);
      }
    }
    if (current_untracked_writes !== null && current_effect !== null && (current_effect.f & CLEAN) !== 0 && current_untracked_writes.includes(signal)) {
      set_signal_status(current_effect, DIRTY);
      schedule_effect(current_effect, false);
    }
  }
  if ((flags & DERIVED) !== 0 && is_signal_dirty(signal)) {
    if (DEV) {
      const previous_inspect_fn = inspect_fn;
      inspect_fn = null;
      update_derived(
        /** @type {import('./types.js').ComputationSignal<V>} **/
        signal,
        false
      );
      inspect_fn = previous_inspect_fn;
    } else {
      update_derived(
        /** @type {import('./types.js').ComputationSignal<V>} **/
        signal,
        false
      );
    }
  }
  return signal.v;
}
function set(signal, value) {
  set_signal_value(signal, value);
  return value;
}
function set_sync(signal, value) {
  flushSync(() => set(signal, value));
}
function invalidate_inner_signals(fn) {
  var previous_is_signals_recorded = is_signals_recorded;
  var previous_captured_signals = captured_signals;
  is_signals_recorded = true;
  captured_signals = /* @__PURE__ */ new Set();
  var captured = captured_signals;
  var signal;
  try {
    untrack(fn);
  } finally {
    is_signals_recorded = previous_is_signals_recorded;
    if (is_signals_recorded) {
      for (signal of captured_signals) {
        previous_captured_signals.add(signal);
      }
    }
    captured_signals = previous_captured_signals;
  }
  for (signal of captured) {
    mutate(
      signal,
      null
      /* doesnt matter */
    );
  }
}
function mutate(source2, value) {
  set_signal_value(
    source2,
    untrack(() => get(source2))
  );
  return value;
}
function mutate_store(store, expression, new_value) {
  store.set(new_value);
  return expression;
}
function mark_subtree_children_inert(signal, inert, visited_blocks) {
  const references = signal.r;
  if (references !== null) {
    let i;
    for (i = 0; i < references.length; i++) {
      mark_subtree_inert(references[i], inert, visited_blocks);
    }
  }
}
function mark_subtree_inert(signal, inert, visited_blocks = /* @__PURE__ */ new Set()) {
  const flags = signal.f;
  const is_already_inert = (flags & INERT) !== 0;
  if (is_already_inert !== inert) {
    signal.f ^= INERT;
    if (!inert && (flags & IS_EFFECT) !== 0 && (flags & CLEAN) === 0) {
      schedule_effect(
        /** @type {import('./types.js').EffectSignal} */
        signal,
        false
      );
    }
    const block = signal.b;
    if (block !== null && !visited_blocks.has(block)) {
      visited_blocks.add(block);
      const type = block.t;
      if (type === IF_BLOCK) {
        const condition_effect = block.e;
        if (condition_effect !== null && block !== current_block) {
          mark_subtree_inert(condition_effect, inert);
        }
        const consequent_effect = block.ce;
        if (consequent_effect !== null && block.v) {
          mark_subtree_inert(consequent_effect, inert, visited_blocks);
        }
        const alternate_effect = block.ae;
        if (alternate_effect !== null && !block.v) {
          mark_subtree_inert(alternate_effect, inert, visited_blocks);
        }
      } else if (type === EACH_BLOCK) {
        const items = block.v;
        for (let { e: each_item_effect } of items) {
          if (each_item_effect !== null) {
            mark_subtree_inert(each_item_effect, inert, visited_blocks);
          }
        }
      }
    }
  }
  mark_subtree_children_inert(signal, inert, visited_blocks);
}
function mark_signal_consumers(signal, to_status, force_schedule) {
  const runes = is_runes(signal.x);
  const consumers = signal.c;
  if (consumers !== null) {
    const length = consumers.length;
    let i;
    for (i = 0; i < length; i++) {
      const consumer = consumers[i];
      const flags = consumer.f;
      const unowned = (flags & UNOWNED) !== 0;
      const dirty = (flags & DIRTY) !== 0;
      if (dirty && !unowned || (!force_schedule || !runes) && consumer === current_effect) {
        continue;
      }
      set_signal_status(consumer, to_status);
      if ((flags & CLEAN) !== 0 || dirty && unowned) {
        if ((consumer.f & IS_EFFECT) !== 0) {
          schedule_effect(
            /** @type {import('./types.js').EffectSignal} */
            consumer,
            false
          );
        } else {
          mark_signal_consumers(consumer, MAYBE_DIRTY, force_schedule);
        }
      }
    }
  }
}
function set_signal_value(signal, value) {
  if (!current_untracking && !ignore_mutation_validation && current_consumer !== null && is_runes(signal.x) && (current_consumer.f & DERIVED) !== 0) {
    throw new Error(
      "ERR_SVELTE_UNSAFE_MUTATION" + (DEV ? `: Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. This can lead to unexpected errors and possibly cause infinite loops.

If this mutation is not meant to be reactive do not use the "$state" rune for that declaration.` : "")
    );
  }
  if ((signal.f & SOURCE) !== 0 && !/** @type {import('./types.js').EqualsFunctions} */
  signal.e(value, signal.v)) {
    const component_context = signal.x;
    signal.v = value;
    if (is_runes(component_context) && current_effect !== null && current_effect.c === null && (current_effect.f & CLEAN) !== 0) {
      if (current_dependencies !== null && current_dependencies.includes(signal)) {
        set_signal_status(current_effect, DIRTY);
        schedule_effect(current_effect, false);
      } else {
        if (current_untracked_writes === null) {
          current_untracked_writes = [signal];
        } else {
          current_untracked_writes.push(signal);
        }
      }
    }
    mark_signal_consumers(signal, DIRTY, true);
    if (current_effect === null && current_queued_pre_and_render_effects.length === 0) {
      const update_callbacks = component_context == null ? void 0 : component_context.u;
      if (update_callbacks != null) {
        run_all(update_callbacks.b);
        const managed = managed_effect(() => {
          destroy_signal(managed);
          run_all(update_callbacks.a);
        });
      }
    }
    if (DEV && signal.inspect) {
      if (is_batching_effect) {
        last_inspected_signal = /** @type {import('./types.js').SignalDebug} */
        signal;
      } else {
        for (
          const fn of
          /** @type {import('./types.js').SignalDebug} */
          signal.inspect
        )
          fn();
      }
    }
  }
}
function destroy_signal(signal) {
  const teardown = (
    /** @type {null | (() => void)} */
    signal.v
  );
  const destroy = signal.y;
  const flags = signal.f;
  destroy_references(signal);
  remove_consumers(signal, 0, true);
  signal.i = signal.r = signal.y = signal.x = signal.b = // @ts-expect-error - this is fine, since we're assigning to null to clear out a destroyed signal
  signal.v = signal.d = signal.c = null;
  set_signal_status(signal, DESTROYED);
  if (destroy !== null) {
    if (is_array(destroy)) {
      run_all(destroy);
    } else {
      destroy();
    }
  }
  if (teardown !== null && (flags & IS_EFFECT) !== 0) {
    teardown();
  }
}
function derived(init2) {
  const is_unowned = current_effect === null;
  const flags = is_unowned ? DERIVED | UNOWNED : DERIVED;
  const signal = (
    /** @type {import('./types.js').ComputationSignal<V>} */
    create_computation_signal(flags | CLEAN, UNINITIALIZED, current_block)
  );
  signal.i = init2;
  signal.x = current_component_context;
  signal.e = default_equals;
  if (!is_unowned) {
    push_reference(
      /** @type {import('./types.js').EffectSignal} */
      current_effect,
      signal
    );
  }
  return signal;
}
function source(initial_value) {
  const source2 = create_source_signal(SOURCE | CLEAN, initial_value);
  source2.x = current_component_context;
  return source2;
}
function mutable_source(initial_value) {
  const s = source(initial_value);
  s.e = safe_equal;
  return s;
}
function untrack(fn) {
  const previous_untracking = current_untracking;
  try {
    current_untracking = true;
    return fn();
  } finally {
    current_untracking = previous_untracking;
  }
}
function internal_create_effect(type, init2, sync, block, schedule) {
  const signal = create_computation_signal(type | DIRTY, null, block);
  signal.i = init2;
  signal.x = current_component_context;
  if (current_effect !== null) {
    signal.l = current_effect.l + 1;
    if ((type & MANAGED) === 0) {
      push_reference(current_effect, signal);
    }
  }
  if (schedule) {
    schedule_effect(signal, sync);
  }
  return signal;
}
function effect_active() {
  return current_effect ? (current_effect.f & MANAGED) === 0 : false;
}
function user_effect(init2) {
  if (current_effect === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_EFFECT" + (DEV ? ": The Svelte $effect rune can only be used during component initialisation." : "")
    );
  }
  const apply_component_effect_heuristics = current_effect.f & RENDER_EFFECT && current_component_context !== null && !current_component_context.m;
  const effect2 = internal_create_effect(
    EFFECT,
    init2,
    false,
    current_block,
    !apply_component_effect_heuristics
  );
  if (apply_component_effect_heuristics) {
    let effects = (
      /** @type {import('./types.js').ComponentContext} */
      current_component_context.e
    );
    if (effects === null) {
      effects = /** @type {import('./types.js').ComponentContext} */
      current_component_context.e = [];
    }
    effects.push(effect2);
  }
  return effect2;
}
function user_root_effect(init2) {
  const effect2 = managed_render_effect(init2);
  return () => {
    destroy_signal(effect2);
  };
}
function effect(init2) {
  return internal_create_effect(EFFECT, init2, false, current_block, true);
}
function managed_effect(init2) {
  return internal_create_effect(EFFECT | MANAGED, init2, false, current_block, true);
}
function managed_pre_effect(init2, sync) {
  return internal_create_effect(PRE_EFFECT | MANAGED, init2, sync, current_block, true);
}
function pre_effect(init2) {
  if (current_effect === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_EFFECT" + (DEV ? ": The Svelte $effect.pre rune can only be used during component initialisation." : "")
    );
  }
  const sync = current_effect !== null && (current_effect.f & RENDER_EFFECT) !== 0;
  return internal_create_effect(
    PRE_EFFECT,
    () => {
      const val = init2();
      flush_local_render_effects();
      return val;
    },
    sync,
    current_block,
    true
  );
}
function invalidate_effect(init2) {
  return internal_create_effect(PRE_EFFECT, init2, true, current_block, true);
}
function render_effect(init2, block = current_block, managed = false, sync = true) {
  let flags = RENDER_EFFECT;
  if (managed) {
    flags |= MANAGED;
  }
  return internal_create_effect(
    flags,
    /** @type {any} */
    init2,
    sync,
    block,
    true
  );
}
function managed_render_effect(init2, block = current_block, sync = true) {
  const flags = RENDER_EFFECT | MANAGED;
  return internal_create_effect(
    flags,
    /** @type {any} */
    init2,
    sync,
    block,
    true
  );
}
function push_destroy_fn(signal, destroy_fn) {
  let destroy = signal.y;
  if (destroy === null) {
    signal.y = destroy_fn;
  } else if (is_array(destroy)) {
    destroy.push(destroy_fn);
  } else {
    signal.y = [destroy, destroy_fn];
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function is_signal(val) {
  return typeof val === "object" && val !== null && typeof /** @type {import('./types.js').Signal<V>} */
  val.f === "number";
}
function is_lazy_property(val) {
  return typeof val === "object" && val !== null && /** @type {import('./types.js').LazyProperty<O, P>} */
  val.t === LAZY_PROPERTY;
}
function prop(props, key, flags, initial) {
  var _a;
  var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
  var runes = (flags & PROPS_IS_RUNES) !== 0;
  var setter = (_a = get_descriptor(props, key)) == null ? void 0 : _a.set;
  if (DEV && setter && runes && initial !== void 0) {
    throw new Error("Cannot use fallback values with bind:");
  }
  var prop_value = (
    /** @type {V} */
    props[key]
  );
  if (prop_value === void 0 && initial !== void 0) {
    if ((flags & PROPS_IS_LAZY_INITIAL) !== 0)
      initial = initial();
    if (DEV && runes) {
      initial = readonly(proxy(
        /** @type {any} */
        initial
      ));
    }
    prop_value = /** @type {V} */
    initial;
    if (setter)
      setter(prop_value);
  }
  var getter = () => {
    var value = (
      /** @type {V} */
      props[key]
    );
    if (value !== void 0)
      initial = void 0;
    return value === void 0 ? (
      /** @type {V} */
      initial
    ) : value;
  };
  if ((flags & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    return function(value) {
      if (arguments.length === 1) {
        setter(value);
        return value;
      } else {
        return getter();
      }
    };
  }
  var from_child = false;
  var was_from_child = false;
  var inner_current_value = mutable_source(prop_value);
  var current_value = derived(() => {
    var parent_value = getter();
    var child_value = get(inner_current_value);
    if (from_child) {
      from_child = false;
      was_from_child = true;
      return child_value;
    }
    was_from_child = false;
    return inner_current_value.v = parent_value;
  });
  if (!immutable)
    current_value.e = safe_equal;
  return function(value, mutation = false) {
    var current = get(current_value);
    if (is_signals_recorded) {
      from_child = was_from_child;
      getter();
      get(inner_current_value);
    }
    if (arguments.length > 0) {
      if (mutation || (immutable ? value !== current : safe_not_equal(value, current))) {
        from_child = true;
        set(inner_current_value, mutation ? current : value);
        get(current_value);
      }
      return value;
    }
    return current;
  };
}
function safe_not_equal(a, b) {
  return a != a ? (
    // eslint-disable-next-line eqeqeq
    b == b
  ) : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equal(a, b) {
  return !safe_not_equal(a, b);
}
function get_or_init_context_map() {
  const component_context = current_component_context;
  if (component_context === null) {
    throw new Error(
      "ERR_SVELTE_ORPHAN_CONTEXT" + (DEV ? "Context can only be used during component initialisation." : "")
    );
  }
  let context_map = component_context.c;
  if (context_map === null) {
    const parent_context = get_parent_context(component_context);
    context_map = component_context.c = new Map(parent_context || void 0);
  }
  return context_map;
}
function get_parent_context(component_context) {
  let parent = component_context.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
function bubble_event($$props, event) {
  var _a;
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    (_a = $$props.$$events) == null ? void 0 : _a[event.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn of callbacks) {
    fn.call(this, event);
  }
}
function update(signal, d = 1) {
  const value = get(signal);
  set_signal_value(signal, value + d);
  return value;
}
function update_prop(fn, d = 1) {
  const value = fn();
  fn(value + d);
  return value;
}
function update_store(store, store_value, d = 1) {
  store.set(store_value + d);
  return store_value;
}
function update_pre(signal, d = 1) {
  const value = get(signal) + d;
  set_signal_value(signal, value);
  return value;
}
function update_pre_prop(fn, d = 1) {
  const value = fn() + d;
  fn(value);
  return value;
}
function update_pre_store(store, store_value, d = 1) {
  const value = store_value + d;
  store.set(value);
  return value;
}
function reactive_import(fn) {
  const s = source(0);
  return function() {
    if (arguments.length === 1) {
      set(s, get(s) + 1);
      return arguments[0];
    } else {
      get(s);
      return fn();
    }
  };
}
function exclude_from_object(obj, keys) {
  obj = { ...obj };
  let key;
  for (key of keys) {
    delete obj[key];
  }
  return obj;
}
function value_or_fallback(value, fallback) {
  return value === void 0 ? fallback : value;
}
function onDestroy(fn) {
  if (!is_ssr) {
    user_effect(() => () => untrack(fn));
  }
}
function push(props, runes = false) {
  current_component_context = {
    // accessors
    a: null,
    // context
    c: null,
    // effects
    e: null,
    // mounted
    m: false,
    // parent
    p: current_component_context,
    // props
    s: props,
    // runes
    r: runes,
    // update_callbacks
    u: null
  };
}
function pop(accessors) {
  const context_stack_item = current_component_context;
  if (context_stack_item !== null) {
    if (accessors !== void 0) {
      context_stack_item.a = accessors;
    }
    const effects = context_stack_item.e;
    if (effects !== null) {
      context_stack_item.e = null;
      for (let i = 0; i < effects.length; i++) {
        schedule_effect(effects[i], false);
      }
    }
    current_component_context = context_stack_item.p;
    context_stack_item.m = true;
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && !visited.has(value)) {
    visited.add(value);
    for (let key in value) {
      deep_read(value[key], visited);
    }
    const proto = Object.getPrototypeOf(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key in descriptors) {
        const get2 = descriptors[key].get;
        if (get2) {
          get2.call(value);
        }
      }
    }
  }
}
function deep_unstate(value, visited = /* @__PURE__ */ new Map()) {
  if (typeof value === "object" && value !== null && !visited.has(value)) {
    const unstated = unstate(value);
    if (unstated !== value) {
      visited.set(value, unstated);
      return unstated;
    }
    let contains_unstated = false;
    const nested_unstated = Array.isArray(value) ? [] : {};
    for (let key in value) {
      const result = deep_unstate(value[key], visited);
      nested_unstated[key] = result;
      if (result !== value[key]) {
        contains_unstated = true;
      }
    }
    visited.set(value, contains_unstated ? nested_unstated : value);
  }
  return visited.get(value) ?? value;
}
var warned_inspect_changed = false;
function inspect(get_value, inspect2 = console.log) {
  let initial = true;
  pre_effect(() => {
    const fn = () => {
      const value2 = get_value().map((v) => deep_unstate(v));
      if (value2.length === 2 && typeof value2[1] === "function" && !warned_inspect_changed) {
        console.warn(
          "$inspect() API has changed. See https://svelte-5-preview.vercel.app/docs/runes#$inspect for more information."
        );
        warned_inspect_changed = true;
      }
      inspect2(initial ? "init" : "update", ...value2);
    };
    inspect_fn = fn;
    const value = get_value();
    deep_read(value);
    inspect_fn = null;
    const signals = inspect_captured_signals.slice();
    inspect_captured_signals = [];
    if (initial) {
      fn();
      initial = false;
    }
    return () => {
      for (const s of signals) {
        s.inspect.delete(fn);
      }
    };
  });
}
function lazy_property(o, p) {
  return {
    o,
    p,
    t: LAZY_PROPERTY
  };
}
function unwrap(value) {
  if (is_signal(value)) {
    return get(value);
  }
  if (is_lazy_property(value)) {
    return value.o[value.p];
  }
  return value;
}
if (DEV) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      globalThis[rune] = () => {
        throw new Error(`${rune} is only available inside .svelte and .svelte.js/ts files`);
      };
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
}
function freeze(value) {
  if (typeof value === "object" && value != null && !is_frozen(value)) {
    if (STATE_SYMBOL in value) {
      return object_freeze(unstate(value));
    }
    if (DEV && READONLY_SYMBOL in value) {
      return value;
    }
    object_freeze(value);
  }
  return value;
}

// node_modules/svelte/src/internal/client/proxy/proxy.js
var STATE_SYMBOL = Symbol("$state");
var READONLY_SYMBOL = Symbol("readonly");
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_frozen2 = Object.isFrozen;
function proxy(value, immutable = true) {
  if (typeof value === "object" && value != null && !is_frozen2(value)) {
    if (STATE_SYMBOL in value) {
      return (
        /** @type {T} */
        value[STATE_SYMBOL].p
      );
    }
    const prototype = get_prototype_of(value);
    if (prototype === object_prototype || prototype === array_prototype) {
      const proxy2 = new Proxy(value, handler2);
      define_property(value, STATE_SYMBOL, {
        value: init(value, proxy2, immutable),
        writable: false
      });
      return proxy2;
    }
  }
  return value;
}
function unwrap2(value, already_unwrapped = /* @__PURE__ */ new Map()) {
  if (typeof value === "object" && value != null && !is_frozen2(value) && STATE_SYMBOL in value) {
    const unwrapped = already_unwrapped.get(value);
    if (unwrapped !== void 0) {
      return unwrapped;
    }
    if (is_array(value)) {
      const array = [];
      already_unwrapped.set(value, array);
      for (const element of value) {
        array.push(unwrap2(element, already_unwrapped));
      }
      return array;
    } else {
      const obj = {};
      const keys = object_keys(value);
      const descriptors = get_descriptors(value);
      already_unwrapped.set(value, obj);
      for (const key of keys) {
        if (descriptors[key].get) {
          define_property(obj, key, descriptors[key]);
        } else {
          const property = value[key];
          obj[key] = unwrap2(property, already_unwrapped);
        }
      }
      return obj;
    }
  }
  return value;
}
function unstate(value) {
  return (
    /** @type {T} */
    unwrap2(
      /** @type {StateObject} */
      value
    )
  );
}
function init(value, proxy2, immutable) {
  return {
    s: /* @__PURE__ */ new Map(),
    v: source(0),
    a: is_array(value),
    i: immutable,
    p: proxy2
  };
}
var handler2 = {
  defineProperty(target, prop2, descriptor) {
    if (descriptor.value) {
      const metadata = target[STATE_SYMBOL];
      const s = metadata.s.get(prop2);
      if (s !== void 0)
        set(s, proxy(descriptor.value, metadata.i));
    }
    return Reflect.defineProperty(target, prop2, descriptor);
  },
  deleteProperty(target, prop2) {
    const metadata = target[STATE_SYMBOL];
    const s = metadata.s.get(prop2);
    const is_array2 = metadata.a;
    const boolean = delete target[prop2];
    if (is_array2 && boolean) {
      const ls = metadata.s.get("length");
      const length = target.length - 1;
      if (ls !== void 0 && ls.v !== length) {
        set(ls, length);
      }
    }
    if (s !== void 0)
      set(s, UNINITIALIZED);
    if (prop2 in target)
      update(metadata.v);
    return boolean;
  },
  get(target, prop2, receiver) {
    var _a;
    if (DEV && prop2 === READONLY_SYMBOL) {
      return Reflect.get(target, READONLY_SYMBOL);
    }
    const metadata = target[STATE_SYMBOL];
    let s = metadata.s.get(prop2);
    if (s === void 0 && (effect_active() || updating_derived) && (!(prop2 in target) || ((_a = get_descriptor(target, prop2)) == null ? void 0 : _a.writable))) {
      s = (metadata.i ? source : mutable_source)(proxy(target[prop2], metadata.i));
      metadata.s.set(prop2, s);
    }
    if (s !== void 0) {
      const value = get(s);
      return value === UNINITIALIZED ? void 0 : value;
    }
    if (DEV) {
      if (typeof target[prop2] === "function" && prop2 !== Symbol.iterator) {
        return batch_inspect(target, prop2, receiver);
      }
    }
    return Reflect.get(target, prop2, receiver);
  },
  getOwnPropertyDescriptor(target, prop2) {
    const descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
    if (descriptor && "value" in descriptor) {
      const metadata = target[STATE_SYMBOL];
      const s = metadata.s.get(prop2);
      if (s) {
        descriptor.value = get(s);
      }
    }
    return descriptor;
  },
  has(target, prop2) {
    var _a;
    if (DEV && prop2 === READONLY_SYMBOL) {
      return Reflect.has(target, READONLY_SYMBOL);
    }
    if (prop2 === STATE_SYMBOL) {
      return true;
    }
    const metadata = target[STATE_SYMBOL];
    const has = Reflect.has(target, prop2);
    let s = metadata.s.get(prop2);
    if (s !== void 0 || effect_active() && (!has || ((_a = get_descriptor(target, prop2)) == null ? void 0 : _a.writable))) {
      if (s === void 0) {
        s = (metadata.i ? source : mutable_source)(
          has ? proxy(target[prop2], metadata.i) : UNINITIALIZED
        );
        metadata.s.set(prop2, s);
      }
      const value = get(s);
      if (value === UNINITIALIZED) {
        return false;
      }
    }
    return has;
  },
  set(target, prop2, value) {
    if (DEV && prop2 === READONLY_SYMBOL) {
      target[READONLY_SYMBOL] = value;
      return true;
    }
    const metadata = target[STATE_SYMBOL];
    const s = metadata.s.get(prop2);
    if (s !== void 0)
      set(s, proxy(value, metadata.i));
    const is_array2 = metadata.a;
    const not_has = !(prop2 in target);
    if (is_array2 && prop2 === "length") {
      for (let i = value; i < target.length; i += 1) {
        const s2 = metadata.s.get(i + "");
        if (s2 !== void 0)
          set(s2, UNINITIALIZED);
      }
    }
    if (not_has) {
      update(metadata.v);
    }
    target[prop2] = value;
    if (is_array2 && not_has) {
      const ls = metadata.s.get("length");
      const length = target.length;
      if (ls !== void 0 && ls.v !== length) {
        set(ls, length);
      }
    }
    return true;
  },
  ownKeys(target) {
    const metadata = target[STATE_SYMBOL];
    get(metadata.v);
    return Reflect.ownKeys(target);
  }
};
if (DEV) {
  handler2.setPrototypeOf = () => {
    throw new Error("Cannot set prototype of $state object");
  };
}

// node_modules/svelte/src/internal/client/validate.js
var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(tag) {
  return void_element_names.test(tag) || tag.toLowerCase() === "!doctype";
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    throw new Error(`'${name}' is not a store with a 'subscribe' method`);
  }
}
function validate_dynamic_component(component_fn) {
  const error_message = "this={...} of <svelte:component> should specify a Svelte component.";
  try {
    const instance = component_fn();
    if (instance !== void 0 && typeof instance !== "object") {
      throw new Error(error_message);
    }
    return instance;
  } catch (err) {
    const { message } = (
      /** @type {Error} */
      err
    );
    if (typeof message === "string" && message.indexOf("is not a function") !== -1) {
      throw new Error(error_message);
    } else {
      throw err;
    }
  }
}
function validate_void_dynamic_element(tag_fn) {
  const tag = tag_fn();
  if (tag && is_void(tag)) {
    console.warn(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag = tag_fn();
  const is_string = typeof tag === "string";
  if (tag && !is_string) {
    throw new Error('<svelte:element> expects "this" attribute to be a string.');
  }
}
function validate_each_keys(collection, key_fn) {
  const keys = /* @__PURE__ */ new Map();
  const maybe_array = untrack(() => collection());
  const array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
  const length = array.length;
  for (let i = 0; i < length; i++) {
    const key = key_fn(array[i], i);
    if (keys.has(key)) {
      throw new Error(
        `Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(
          key
        )} and ${i} with value '${array[i]}' are duplicates`
      );
    }
    keys.set(key, i);
  }
}
function loop_guard(timeout) {
  const start = Date.now();
  return () => {
    if (Date.now() - start > timeout) {
      throw new Error("Infinite loop detected");
    }
  };
}
var snippet_symbol = Symbol.for("svelte.snippet");
function add_snippet_symbol(fn) {
  fn[snippet_symbol] = true;
  return fn;
}
function validate_snippet(snippet_fn) {
  if (snippet_fn[snippet_symbol] !== true) {
    throw new Error(
      "The argument to `{@render ...}` must be a snippet function, not a component or some other kind of function. If you want to dynamically render one snippet or another, use `$derived` and pass its result to `{@render ...}`."
    );
  }
  return snippet_fn;
}
function validate_component(component_fn) {
  if ((component_fn == null ? void 0 : component_fn[snippet_symbol]) === true) {
    throw new Error("A snippet must be rendered with `{@render ...}`");
  }
  return component_fn;
}

export {
  is_array,
  array_from,
  object_keys,
  object_assign,
  define_property,
  get_descriptor,
  get_descriptors,
  is_function,
  EACH_ITEM_REACTIVE,
  EACH_INDEX_REACTIVE,
  EACH_KEYED,
  EACH_IS_CONTROLLED,
  EACH_IS_ANIMATED,
  EACH_IS_IMMUTABLE,
  DelegatedEvents,
  PassiveDelegatedEvents,
  AttributeAliases,
  DOMBooleanAttributes,
  STATE_SYMBOL,
  proxy,
  unstate,
  readonly,
  ROOT_BLOCK,
  IF_BLOCK,
  EACH_BLOCK,
  EACH_ITEM_BLOCK,
  AWAIT_BLOCK,
  KEY_BLOCK,
  DYNAMIC_COMPONENT_BLOCK,
  create_root_block,
  create_if_block,
  create_key_block,
  create_head_block,
  create_dynamic_element_block,
  create_dynamic_component_block,
  create_await_block,
  create_each_block,
  create_each_item_block,
  create_snippet_block,
  UNINITIALIZED,
  current_effect,
  current_block,
  current_component_context,
  is_ssr,
  set_is_ssr,
  execute_effect,
  schedule_task,
  schedule_raf_task,
  flush_local_render_effects,
  flushSync,
  tick,
  store_get,
  store_set,
  unsubscribe_on_destroy,
  get,
  set,
  set_sync,
  invalidate_inner_signals,
  mutate,
  mutate_store,
  mark_subtree_inert,
  set_signal_value,
  destroy_signal,
  derived,
  source,
  mutable_source,
  untrack,
  effect_active,
  user_effect,
  user_root_effect,
  effect,
  managed_effect,
  managed_pre_effect,
  pre_effect,
  invalidate_effect,
  render_effect,
  push_destroy_fn,
  is_signal,
  is_lazy_property,
  prop,
  safe_not_equal,
  safe_equal,
  get_or_init_context_map,
  bubble_event,
  update,
  update_prop,
  update_store,
  update_pre,
  update_pre_prop,
  update_pre_store,
  reactive_import,
  exclude_from_object,
  value_or_fallback,
  onDestroy,
  push,
  pop,
  inspect,
  lazy_property,
  unwrap,
  freeze,
  validate_store,
  validate_dynamic_component,
  validate_void_dynamic_element,
  validate_dynamic_element_tag,
  validate_each_keys,
  loop_guard,
  add_snippet_symbol,
  validate_snippet,
  validate_component
};
//# sourceMappingURL=chunk-Y7FRHIMW.js.map

{
  "version": 3,
  "sources": ["../../svelte/src/internal/client/utils.js", "../../svelte/src/constants.js", "../../svelte/src/internal/client/proxy/readonly.js", "../../svelte/src/internal/client/block.js", "../../svelte/src/internal/client/runtime.js", "../../svelte/src/internal/client/proxy/proxy.js", "../../svelte/src/internal/client/validate.js"],
  "sourcesContent": ["// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var object_entries = Object.entries;\nexport var object_assign = Object.assign;\nexport var is_frozen = Object.isFrozen;\nexport var object_freeze = Object.freeze;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n", "export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\nexport const EACH_KEYED = 1 << 2;\nexport const EACH_PROXIED = 1 << 3;\nexport const EACH_IS_CONTROLLED = 1 << 3;\nexport const EACH_IS_ANIMATED = 1 << 4;\nexport const EACH_IS_IMMUTABLE = 1 << 6;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 3;\n\n/** List of Element events that will be delegated */\nexport const DelegatedEvents = [\n\t'beforeinput',\n\t'click',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t// 'input', This conflicts with bind:input\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/** List of Element events that will be delegated and are passive */\nexport const PassiveDelegatedEvents = ['touchstart', 'touchmove', 'touchend'];\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nexport const AttributeAliases = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nexport const DOMBooleanAttributes = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected'\n];\n", "import { define_property, is_frozen } from '../utils.js';\nimport { READONLY_SYMBOL, STATE_SYMBOL } from './proxy.js';\n\n/**\n * @template {Record<string | symbol, any>} T\n * @typedef {T & { [READONLY_SYMBOL]: Proxy<T> }} StateObject\n */\n\n/**\n * Expects a value that was wrapped with `proxy` and makes it readonly.\n *\n * @template {Record<string | symbol, any>} T\n * @template {StateObject<T>} U\n * @param {U} value\n * @returns {Proxy<U> | U}\n */\nexport function readonly(value) {\n\tconst proxy = value && value[READONLY_SYMBOL];\n\tif (proxy) return proxy;\n\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\tSTATE_SYMBOL in value && // TODO handle Map and Set as well\n\t\t!(READONLY_SYMBOL in value)\n\t) {\n\t\tconst proxy = new Proxy(value, handler);\n\t\tdefine_property(value, READONLY_SYMBOL, { value: proxy, writable: false });\n\t\treturn proxy;\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {any}\t_\n * @param {string} prop\n * @returns {never}\n */\nconst readonly_error = (_, prop) => {\n\tthrow new Error(\n\t\t`Non-bound props cannot be mutated â€” to make the \\`${prop}\\` settable, ensure the object it is used within is bound as a prop \\`bind:<prop>={...}\\`. Fallback values can never be mutated.`\n\t);\n};\n\n/** @type {ProxyHandler<StateObject<any>>} */\nconst handler = {\n\tdefineProperty: readonly_error,\n\tdeleteProperty: readonly_error,\n\tset: readonly_error,\n\n\tget(target, prop, receiver) {\n\t\tconst value = Reflect.get(target, prop, receiver);\n\n\t\tif (!(prop in target)) {\n\t\t\treturn readonly(value);\n\t\t}\n\n\t\treturn value;\n\t}\n};\n", "import { current_block } from './runtime.js';\n\nexport const ROOT_BLOCK = 0;\nexport const IF_BLOCK = 1;\nexport const EACH_BLOCK = 2;\nexport const EACH_ITEM_BLOCK = 3;\nexport const AWAIT_BLOCK = 4;\nexport const KEY_BLOCK = 5;\nexport const HEAD_BLOCK = 6;\nexport const DYNAMIC_COMPONENT_BLOCK = 7;\nexport const DYNAMIC_ELEMENT_BLOCK = 8;\nexport const SNIPPET_BLOCK = 9;\n\n/**\n * @param {boolean} intro\n * @returns {import('./types.js').RootBlock}\n */\nexport function create_root_block(intro) {\n\treturn {\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// intro\n\t\ti: intro,\n\t\t// parent\n\t\tp: null,\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: ROOT_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').IfBlock} */\nexport function create_if_block() {\n\treturn {\n\t\t// alternate transitions\n\t\ta: null,\n\t\t// alternate effect\n\t\tae: null,\n\t\t// consequent transitions\n\t\tc: null,\n\t\t// consequent effect\n\t\tce: null,\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// parent\n\t\tp: /** @type {import('./types.js').Block} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: IF_BLOCK,\n\t\t// value\n\t\tv: false\n\t};\n}\n\n/** @returns {import('./types.js').KeyBlock} */\nexport function create_key_block() {\n\treturn {\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// parent\n\t\tp: /** @type {import('./types.js').Block} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: KEY_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').HeadBlock} */\nexport function create_head_block() {\n\treturn {\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// parent\n\t\tp: /** @type {import('./types.js').Block} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: HEAD_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').DynamicElementBlock} */\nexport function create_dynamic_element_block() {\n\treturn {\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// parent\n\t\tp: /** @type {import('./types.js').Block} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: DYNAMIC_ELEMENT_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').DynamicComponentBlock} */\nexport function create_dynamic_component_block() {\n\treturn {\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// parent\n\t\tp: /** @type {import('./types.js').Block} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: DYNAMIC_COMPONENT_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').AwaitBlock} */\nexport function create_await_block() {\n\treturn {\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// parent\n\t\tp: /** @type {import('./types.js').Block} */ (current_block),\n\t\t// pending\n\t\tn: true,\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: AWAIT_BLOCK\n\t};\n}\n\n/**\n * @param {number} flags\n * @param {Element | Comment} anchor\n * @returns {import('./types.js').EachBlock}\n */\nexport function create_each_block(flags, anchor) {\n\treturn {\n\t\t// anchor\n\t\ta: anchor,\n\t\t// dom\n\t\td: null,\n\t\t// flags\n\t\tf: flags,\n\t\t// items\n\t\tv: [],\n\t\t// effect\n\t\te: null,\n\t\tp: /** @type {import('./types.js').Block} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// transitions\n\t\ts: [],\n\t\t// type\n\t\tt: EACH_BLOCK\n\t};\n}\n\n/**\n * @param {any | import('./types.js').Signal<any>} item\n * @param {number | import('./types.js').Signal<number>} index\n * @param {null | unknown} key\n * @returns {import('./types.js').EachItemBlock}\n */\nexport function create_each_item_block(item, index, key) {\n\treturn {\n\t\t// animate transition\n\t\ta: null,\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// index\n\t\ti: index,\n\t\t// key\n\t\tk: key,\n\t\t// item\n\t\tv: item,\n\t\t// parent\n\t\tp: /** @type {import('./types.js').EachBlock} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// transitions\n\t\ts: null,\n\t\t// type\n\t\tt: EACH_ITEM_BLOCK\n\t};\n}\n\n/** @returns {import('./types.js').SnippetBlock} */\nexport function create_snippet_block() {\n\treturn {\n\t\t// dom\n\t\td: null,\n\t\t// parent\n\t\tp: /** @type {import('./types.js').Block} */ (current_block),\n\t\t// effect\n\t\te: null,\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: SNIPPET_BLOCK\n\t};\n}\n", "import { DEV } from 'esm-env';\nimport { subscribe_to_store } from '../../store/utils.js';\nimport { EMPTY_FUNC, run_all } from '../common.js';\nimport { get_descriptor, get_descriptors, is_array, is_frozen, object_freeze } from './utils.js';\nimport {\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../constants.js';\nimport { readonly } from './proxy/readonly.js';\nimport { READONLY_SYMBOL, STATE_SYMBOL, proxy, unstate } from './proxy/proxy.js';\nimport { EACH_BLOCK, IF_BLOCK } from './block.js';\n\nexport const SOURCE = 1;\nexport const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const PRE_EFFECT = 1 << 3;\nexport const RENDER_EFFECT = 1 << 4;\nconst MANAGED = 1 << 6;\nconst UNOWNED = 1 << 7;\nexport const CLEAN = 1 << 8;\nexport const DIRTY = 1 << 9;\nexport const MAYBE_DIRTY = 1 << 10;\nexport const INERT = 1 << 11;\nexport const DESTROYED = 1 << 12;\n\nconst IS_EFFECT = EFFECT | PRE_EFFECT | RENDER_EFFECT;\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\nexport const UNINITIALIZED = Symbol();\nexport const LAZY_PROPERTY = Symbol();\n\n// Used for controlling the flush of effects.\nlet current_scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\nlet is_task_queued = false;\nlet is_raf_queued = false;\n// Used for $inspect\nexport let is_batching_effect = false;\n\n// Handle effect queues\n\n/** @type {import('./types.js').EffectSignal[]} */\nlet current_queued_pre_and_render_effects = [];\n\n/** @type {import('./types.js').EffectSignal[]} */\nlet current_queued_effects = [];\n\n/** @type {Array<() => void>} */\nlet current_queued_tasks = [];\n/** @type {Array<() => void>} */\nlet current_raf_tasks = [];\nlet flush_count = 0;\n// Handle signal reactivity tree dependencies and consumer\n\n/** @type {null | import('./types.js').ComputationSignal} */\nlet current_consumer = null;\n\n/** @type {null | import('./types.js').EffectSignal} */\nexport let current_effect = null;\n\n/** @type {null | import('./types.js').Signal[]} */\nlet current_dependencies = null;\nlet current_dependencies_index = 0;\n/** @type {null | import('./types.js').Signal[]} */\nlet current_untracked_writes = null;\n/** @type {null | import('./types.js').SignalDebug} */\nlet last_inspected_signal = null;\n/** If `true`, `get`ting the signal should not register it as a dependency */\nexport let current_untracking = false;\n/** Exists to opt out of the mutation validation for stores which may be set for the first time during a derivation */\nlet ignore_mutation_validation = false;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the consumer.\nlet current_skip_consumer = false;\n// Handle collecting all signals which are read during a specific time frame\nlet is_signals_recorded = false;\nlet captured_signals = new Set();\n\n/** @type {Function | null} */\nlet inspect_fn = null;\n\n/** @type {Array<import('./types.js').SignalDebug>} */\nlet inspect_captured_signals = [];\n\n// Handle rendering tree blocks and anchors\n/** @type {null | import('./types.js').Block} */\nexport let current_block = null;\n// Handling runtime component context\n\n/** @type {import('./types.js').ComponentContext | null} */\nexport let current_component_context = null;\nexport let is_ssr = false;\n\nexport let updating_derived = false;\n\n/**\n * @param {boolean} ssr\n * @returns {void}\n */\nexport function set_is_ssr(ssr) {\n\tis_ssr = ssr;\n}\n\n/**\n * @param {null | import('./types.js').ComponentContext} context\n * @returns {boolean}\n */\nfunction is_runes(context) {\n\tconst component_context = context || current_component_context;\n\treturn component_context !== null && component_context.r;\n}\n\n/**\n * @param {import(\"./proxy/proxy.js\").StateObject} target\n * @param {string | symbol} prop\n * @param {any} receiver\n */\nexport function batch_inspect(target, prop, receiver) {\n\tconst value = Reflect.get(target, prop, receiver);\n\treturn function () {\n\t\tconst previously_batching_effect = is_batching_effect;\n\t\tis_batching_effect = true;\n\t\ttry {\n\t\t\treturn Reflect.apply(value, receiver, arguments);\n\t\t} finally {\n\t\t\tis_batching_effect = previously_batching_effect;\n\t\t\tif (last_inspected_signal !== null) {\n\t\t\t\tfor (const fn of last_inspected_signal.inspect) fn();\n\t\t\t\tlast_inspected_signal = null;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {null | import('./types.js').ComponentContext} context_stack_item\n * @returns {void}\n */\nexport function set_current_component_context(context_stack_item) {\n\tcurrent_component_context = context_stack_item;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function default_equals(a, b) {\n\treturn a === b;\n}\n\n/**\n * @template V\n * @param {import('./types.js').SignalFlags} flags\n * @param {V} value\n * @returns {import('./types.js').SourceSignal<V> | import('./types.js').SourceSignal<V> & import('./types.js').SourceSignalDebug}\n */\nfunction create_source_signal(flags, value) {\n\tif (DEV) {\n\t\treturn {\n\t\t\t// consumers\n\t\t\tc: null,\n\t\t\t// equals\n\t\t\te: default_equals,\n\t\t\t// flags\n\t\t\tf: flags,\n\t\t\t// value\n\t\t\tv: value,\n\t\t\t// context: We can remove this if we get rid of beforeUpdate/afterUpdate\n\t\t\tx: null,\n\t\t\t// this is for DEV only\n\t\t\tinspect: new Set()\n\t\t};\n\t}\n\treturn {\n\t\t// consumers\n\t\tc: null,\n\t\t// equals\n\t\te: default_equals,\n\t\t// flags\n\t\tf: flags,\n\t\t// value\n\t\tv: value,\n\t\t// context: We can remove this if we get rid of beforeUpdate/afterUpdate\n\t\tx: null\n\t};\n}\n\n/**\n * @template V\n * @param {import('./types.js').SignalFlags} flags\n * @param {V} value\n * @param {import('./types.js').Block | null} block\n * @returns {import('./types.js').ComputationSignal<V> | import('./types.js').ComputationSignal<V> & import('./types.js').SourceSignalDebug}\n */\nfunction create_computation_signal(flags, value, block) {\n\tif (DEV) {\n\t\treturn {\n\t\t\t// block\n\t\t\tb: block,\n\t\t\t// consumers\n\t\t\tc: null,\n\t\t\t// destroy\n\t\t\td: null,\n\t\t\t// equals\n\t\t\te: null,\n\t\t\t// flags\n\t\t\tf: flags,\n\t\t\t// init\n\t\t\ti: null,\n\t\t\t// level\n\t\t\tl: 0,\n\t\t\t// references\n\t\t\tr: null,\n\t\t\t// value\n\t\t\tv: value,\n\t\t\t// context: We can remove this if we get rid of beforeUpdate/afterUpdate\n\t\t\tx: null,\n\t\t\t// destroy\n\t\t\ty: null,\n\t\t\t// this is for DEV only\n\t\t\tinspect: new Set()\n\t\t};\n\t}\n\n\treturn {\n\t\t// block\n\t\tb: block,\n\t\t// consumers\n\t\tc: null,\n\t\t// destroy\n\t\td: null,\n\t\t// equals\n\t\te: null,\n\t\t// flags\n\t\tf: flags,\n\t\t// level\n\t\tl: 0,\n\t\t// init\n\t\ti: null,\n\t\t// references\n\t\tr: null,\n\t\t// value\n\t\tv: value,\n\t\t// context: We can remove this if we get rid of beforeUpdate/afterUpdate\n\t\tx: null,\n\t\t// destroy\n\t\ty: null\n\t};\n}\n\n/**\n * @param {import('./types.js').ComputationSignal} target_signal\n * @param {import('./types.js').ComputationSignal} ref_signal\n * @returns {void}\n */\nfunction push_reference(target_signal, ref_signal) {\n\tconst references = target_signal.r;\n\tif (references === null) {\n\t\ttarget_signal.r = [ref_signal];\n\t} else {\n\t\treferences.push(ref_signal);\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @returns {boolean}\n */\nfunction is_signal_dirty(signal) {\n\tconst flags = signal.f;\n\tif ((flags & DIRTY) !== 0 || signal.v === UNINITIALIZED) {\n\t\treturn true;\n\t}\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tconst dependencies = /** @type {import('./types.js').ComputationSignal<V>} **/ (signal).d;\n\t\tif (dependencies !== null) {\n\t\t\tconst length = dependencies.length;\n\t\t\tlet i;\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tconst dependency = dependencies[i];\n\n\t\t\t\tif ((dependency.f & MAYBE_DIRTY) !== 0 && !is_signal_dirty(dependency)) {\n\t\t\t\t\tset_signal_status(dependency, CLEAN);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// The flags can be marked as dirty from the above is_signal_dirty call.\n\t\t\t\tif ((dependency.f & DIRTY) !== 0) {\n\t\t\t\t\tif ((dependency.f & DERIVED) !== 0) {\n\t\t\t\t\t\tupdate_derived(\n\t\t\t\t\t\t\t/** @type {import('./types.js').ComputationSignal<V>} **/ (dependency),\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Might have been mutated from above get.\n\t\t\t\t\t\tif ((signal.f & DIRTY) !== 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {V}\n */\nfunction execute_signal_fn(signal) {\n\tconst init = signal.i;\n\tconst previous_dependencies = current_dependencies;\n\tconst previous_dependencies_index = current_dependencies_index;\n\tconst previous_untracked_writes = current_untracked_writes;\n\tconst previous_consumer = current_consumer;\n\tconst previous_block = current_block;\n\tconst previous_component_context = current_component_context;\n\tconst previous_skip_consumer = current_skip_consumer;\n\tconst is_render_effect = (signal.f & RENDER_EFFECT) !== 0;\n\tconst previous_untracking = current_untracking;\n\tcurrent_dependencies = /** @type {null | import('./types.js').Signal[]} */ (null);\n\tcurrent_dependencies_index = 0;\n\tcurrent_untracked_writes = null;\n\tcurrent_consumer = signal;\n\tcurrent_block = signal.b;\n\tcurrent_component_context = signal.x;\n\tcurrent_skip_consumer = current_effect === null && (signal.f & UNOWNED) !== 0;\n\tcurrent_untracking = false;\n\n\t// Render effects are invoked when the UI is about to be updated - run beforeUpdate at that point\n\tif (is_render_effect && current_component_context?.u != null) {\n\t\t// update_callbacks.execute()\n\t\tcurrent_component_context.u.e();\n\t}\n\n\ttry {\n\t\tlet res;\n\t\tif (is_render_effect) {\n\t\t\tres =\n\t\t\t\t/** @type {(block: import('./types.js').Block, signal: import('./types.js').Signal) => V} */ (\n\t\t\t\t\tinit\n\t\t\t\t)(\n\t\t\t\t\t/** @type {import('./types.js').Block} */ (signal.b),\n\t\t\t\t\t/** @type {import('./types.js').Signal} */ (signal)\n\t\t\t\t);\n\t\t} else {\n\t\t\tres = /** @type {() => V} */ (init)();\n\t\t}\n\t\tlet dependencies = /** @type {import('./types.js').Signal<unknown>[]} **/ (signal.d);\n\n\t\tif (current_dependencies !== null) {\n\t\t\tlet i;\n\t\t\tif (dependencies !== null) {\n\t\t\t\t// Include any dependencies up until the current_dependencies_index.\n\t\t\t\tconst full_dependencies =\n\t\t\t\t\tcurrent_dependencies_index === 0\n\t\t\t\t\t\t? dependencies\n\t\t\t\t\t\t: dependencies.slice(0, current_dependencies_index).concat(current_dependencies);\n\t\t\t\tconst dep_length = full_dependencies.length;\n\t\t\t\t// If we have more than 16 elements in the array then use a Set for faster performance\n\t\t\t\t// TODO: evaluate if we should always just use a Set or not here?\n\t\t\t\tconst current_dependencies_set = dep_length > 16 ? new Set(full_dependencies) : null;\n\n\t\t\t\tfor (i = current_dependencies_index; i < dep_length; i++) {\n\t\t\t\t\tconst dependency = full_dependencies[i];\n\t\t\t\t\tif (\n\t\t\t\t\t\t(current_dependencies_set !== null && !current_dependencies_set.has(dependency)) ||\n\t\t\t\t\t\t!full_dependencies.includes(dependency)\n\t\t\t\t\t) {\n\t\t\t\t\t\tremove_consumer(signal, dependency, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dependencies !== null && current_dependencies_index > 0) {\n\t\t\t\tdependencies.length = current_dependencies_index + current_dependencies.length;\n\t\t\t\tfor (i = 0; i < current_dependencies.length; i++) {\n\t\t\t\t\tdependencies[current_dependencies_index + i] = current_dependencies[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignal.d = /** @type {import('./types.js').Signal<V>[]} **/ (\n\t\t\t\t\tdependencies = current_dependencies\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!current_skip_consumer) {\n\t\t\t\tfor (i = current_dependencies_index; i < dependencies.length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tconst consumers = dependency.c;\n\n\t\t\t\t\tif (consumers === null) {\n\t\t\t\t\t\tdependency.c = [signal];\n\t\t\t\t\t} else if (consumers[consumers.length - 1] !== signal) {\n\t\t\t\t\t\tconsumers.push(signal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dependencies !== null && current_dependencies_index < dependencies.length) {\n\t\t\tremove_consumers(signal, current_dependencies_index, false);\n\t\t\tdependencies.length = current_dependencies_index;\n\t\t}\n\t\treturn res;\n\t} finally {\n\t\tcurrent_dependencies = previous_dependencies;\n\t\tcurrent_dependencies_index = previous_dependencies_index;\n\t\tcurrent_untracked_writes = previous_untracked_writes;\n\t\tcurrent_consumer = previous_consumer;\n\t\tcurrent_block = previous_block;\n\t\tcurrent_component_context = previous_component_context;\n\t\tcurrent_skip_consumer = previous_skip_consumer;\n\t\tcurrent_untracking = previous_untracking;\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {import('./types.js').Signal<V>} dependency\n * @param {boolean} remove_unowned\n * @returns {void}\n */\nfunction remove_consumer(signal, dependency, remove_unowned) {\n\tconst consumers = dependency.c;\n\tlet consumers_length = 0;\n\tif (consumers !== null) {\n\t\tconsumers_length = consumers.length - 1;\n\t\tconst index = consumers.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tif (consumers_length === 0) {\n\t\t\t\tdependency.c = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\tconsumers[index] = consumers[consumers_length];\n\t\t\t\tconsumers.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (remove_unowned && consumers_length === 0 && (dependency.f & UNOWNED) !== 0) {\n\t\t// If the signal is unowned then we need to make sure to change it to dirty.\n\t\tset_signal_status(dependency, DIRTY);\n\t\tremove_consumers(\n\t\t\t/** @type {import('./types.js').ComputationSignal<V>} **/ (dependency),\n\t\t\t0,\n\t\t\ttrue\n\t\t);\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {number} start_index\n * @param {boolean} remove_unowned\n * @returns {void}\n */\nfunction remove_consumers(signal, start_index, remove_unowned) {\n\tconst dependencies = signal.d;\n\tif (dependencies !== null) {\n\t\tconst active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);\n\t\tlet i;\n\t\tfor (i = start_index; i < dependencies.length; i++) {\n\t\t\tconst dependency = dependencies[i];\n\t\t\t// Avoid removing a consumer if we know that it is active (start_index will not be 0)\n\t\t\tif (active_dependencies === null || !active_dependencies.includes(dependency)) {\n\t\t\t\tremove_consumer(signal, dependency, remove_unowned);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {void}\n */\nfunction destroy_references(signal) {\n\tconst references = signal.r;\n\tsignal.r = null;\n\tif (references !== null) {\n\t\tlet i;\n\t\tfor (i = 0; i < references.length; i++) {\n\t\t\tconst reference = references[i];\n\t\t\tif ((reference.f & IS_EFFECT) !== 0) {\n\t\t\t\tdestroy_signal(reference);\n\t\t\t} else {\n\t\t\t\tremove_consumers(reference, 0, true);\n\t\t\t\treference.d = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./types.js').Block} block\n * @param {unknown} error\n * @returns {void}\n */\nfunction report_error(block, error) {\n\t/** @type {import('./types.js').Block | null} */\n\tlet current_block = block;\n\n\tif (current_block !== null) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * @param {import('./types.js').EffectSignal} signal\n * @returns {void}\n */\nexport function execute_effect(signal) {\n\tif ((signal.f & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\tconst teardown = signal.v;\n\tconst previous_effect = current_effect;\n\tcurrent_effect = signal;\n\n\ttry {\n\t\tdestroy_references(signal);\n\t\tif (teardown !== null) {\n\t\t\tteardown();\n\t\t}\n\t\tconst possible_teardown = execute_signal_fn(signal);\n\t\tif (typeof possible_teardown === 'function') {\n\t\t\tsignal.v = possible_teardown;\n\t\t}\n\t} catch (error) {\n\t\tconst block = signal.b;\n\t\tif (block !== null) {\n\t\t\treport_error(block, error);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tcurrent_effect = previous_effect;\n\t}\n\tconst component_context = signal.x;\n\tif (\n\t\tis_runes(component_context) && // Don't rerun pre effects more than once to accomodate for \"$: only runs once\" behavior\n\t\t(signal.f & PRE_EFFECT) !== 0 &&\n\t\tcurrent_queued_pre_and_render_effects.length > 0\n\t) {\n\t\tflush_local_pre_effects(component_context);\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 100) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_TOO_MANY_UPDATES' +\n\t\t\t\t(DEV\n\t\t\t\t\t? ': Maximum update depth exceeded. This can happen when a reactive block or effect ' +\n\t\t\t\t\t\t'repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<import('./types.js').EffectSignal>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tconst length = effects.length;\n\tif (length > 0) {\n\t\tinfinite_loop_guard();\n\t\tlet i;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tconst signal = effects[i];\n\t\t\tconst flags = signal.f;\n\t\t\tif ((flags & (DESTROYED | INERT)) === 0) {\n\t\t\t\tif (is_signal_dirty(signal)) {\n\t\t\t\t\tset_signal_status(signal, CLEAN);\n\t\t\t\t\texecute_effect(signal);\n\t\t\t\t} else if ((flags & MAYBE_DIRTY) !== 0) {\n\t\t\t\t\tset_signal_status(signal, CLEAN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\teffects.length = 0;\n\t}\n}\n\nfunction process_microtask() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 101) {\n\t\treturn;\n\t}\n\tconst previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;\n\tconst previous_queued_effects = current_queued_effects;\n\tcurrent_queued_pre_and_render_effects = [];\n\tcurrent_queued_effects = [];\n\tflush_queued_effects(previous_queued_pre_and_render_effects);\n\tflush_queued_effects(previous_queued_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n}\n\n/**\n * @param {import('./types.js').EffectSignal} signal\n * @param {boolean} sync\n * @returns {void}\n */\nexport function schedule_effect(signal, sync) {\n\tconst flags = signal.f;\n\tif (sync) {\n\t\texecute_effect(signal);\n\t\tset_signal_status(signal, CLEAN);\n\t} else {\n\t\tif (current_scheduler_mode === FLUSH_MICROTASK) {\n\t\t\tif (!is_micro_task_queued) {\n\t\t\t\tis_micro_task_queued = true;\n\t\t\t\tqueueMicrotask(process_microtask);\n\t\t\t}\n\t\t}\n\t\tif ((flags & EFFECT) !== 0) {\n\t\t\tcurrent_queued_effects.push(signal);\n\t\t\t// Prevent any nested user effects from potentially triggering\n\t\t\t// before this effect is scheduled. We know they will be destroyed\n\t\t\t// so we can make them inert to avoid having to find them in the\n\t\t\t// queue and remove them.\n\t\t\tif ((flags & MANAGED) === 0) {\n\t\t\t\tmark_subtree_children_inert(signal, true);\n\t\t\t}\n\t\t} else {\n\t\t\t// We need to ensure we insert the signal in the right topological order. In other words,\n\t\t\t// we need to evaluate where to insert the signal based off its level and whether or not it's\n\t\t\t// a pre-effect and within the same block. By checking the signals in the queue in reverse order\n\t\t\t// we can find the right place quickly. TODO: maybe opt to use a linked list rather than an array\n\t\t\t// for these operations.\n\t\t\tconst length = current_queued_pre_and_render_effects.length;\n\t\t\tlet should_append = length === 0;\n\n\t\t\tif (!should_append) {\n\t\t\t\tconst target_level = signal.l;\n\t\t\t\tconst target_block = signal.b;\n\t\t\t\tconst is_pre_effect = (flags & PRE_EFFECT) !== 0;\n\t\t\t\tlet target_signal;\n\t\t\t\tlet is_target_pre_effect;\n\t\t\t\tlet i = length;\n\t\t\t\twhile (true) {\n\t\t\t\t\ttarget_signal = current_queued_pre_and_render_effects[--i];\n\t\t\t\t\tif (target_signal.l <= target_level) {\n\t\t\t\t\t\tif (i + 1 === length) {\n\t\t\t\t\t\t\tshould_append = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tis_target_pre_effect = (target_signal.f & PRE_EFFECT) !== 0;\n\t\t\t\t\t\t\tif (target_signal.b !== target_block || (is_target_pre_effect && !is_pre_effect)) {\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 0, signal);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tcurrent_queued_pre_and_render_effects.unshift(signal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (should_append) {\n\t\t\t\tcurrent_queued_pre_and_render_effects.push(signal);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction process_task() {\n\tis_task_queued = false;\n\tconst tasks = current_queued_tasks.slice();\n\tcurrent_queued_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_raf_task() {\n\tis_raf_queued = false;\n\tconst tasks = current_raf_tasks.slice();\n\tcurrent_raf_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n * @returns {void}\n */\nexport function schedule_task(fn) {\n\tif (!is_task_queued) {\n\t\tis_task_queued = true;\n\t\tsetTimeout(process_task, 0);\n\t}\n\tcurrent_queued_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n * @returns {void}\n */\nexport function schedule_raf_task(fn) {\n\tif (!is_raf_queued) {\n\t\tis_raf_queued = true;\n\t\trequestAnimationFrame(process_raf_task);\n\t}\n\tcurrent_raf_tasks.push(fn);\n}\n\n/**\n * @returns {void}\n */\nexport function flush_local_render_effects() {\n\tconst effects = [];\n\tfor (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {\n\t\tconst effect = current_queued_pre_and_render_effects[i];\n\t\tif ((effect.f & RENDER_EFFECT) !== 0 && effect.x === current_component_context) {\n\t\t\teffects.push(effect);\n\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_queued_effects(effects);\n}\n\n/**\n * @param {null | import('./types.js').ComponentContext} context\n * @returns {void}\n */\nexport function flush_local_pre_effects(context) {\n\tconst effects = [];\n\tfor (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {\n\t\tconst effect = current_queued_pre_and_render_effects[i];\n\t\tif ((effect.f & PRE_EFFECT) !== 0 && effect.x === context) {\n\t\t\teffects.push(effect);\n\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_queued_effects(effects);\n}\n\n/**\n * Synchronously flushes any pending state changes and those that result from it.\n * @param {() => void} [fn]\n * @returns {void}\n */\nexport function flushSync(fn) {\n\tconst previous_scheduler_mode = current_scheduler_mode;\n\tconst previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;\n\tconst previous_queued_effects = current_queued_effects;\n\ttry {\n\t\tinfinite_loop_guard();\n\t\t/** @type {import('./types.js').EffectSignal[]} */\n\t\tconst pre_and_render_effects = [];\n\n\t\t/** @type {import('./types.js').EffectSignal[]} */\n\t\tconst effects = [];\n\t\tcurrent_scheduler_mode = FLUSH_SYNC;\n\t\tcurrent_queued_pre_and_render_effects = pre_and_render_effects;\n\t\tcurrent_queued_effects = effects;\n\t\tflush_queued_effects(previous_queued_pre_and_render_effects);\n\t\tflush_queued_effects(previous_queued_effects);\n\t\tif (fn !== undefined) {\n\t\t\tfn();\n\t\t}\n\t\tif (current_queued_pre_and_render_effects.length > 0 || effects.length > 0) {\n\t\t\tflushSync();\n\t\t}\n\t\tif (is_raf_queued) {\n\t\t\tprocess_raf_task();\n\t\t}\n\t\tif (is_task_queued) {\n\t\t\tprocess_task();\n\t\t}\n\t\tflush_count = 0;\n\t} finally {\n\t\tcurrent_scheduler_mode = previous_scheduler_mode;\n\t\tcurrent_queued_pre_and_render_effects = previous_queued_pre_and_render_effects;\n\t\tcurrent_queued_effects = previous_queued_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flushSync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflushSync();\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {boolean} force_schedule\n * @returns {void}\n */\nfunction update_derived(signal, force_schedule) {\n\tconst previous_updating_derived = updating_derived;\n\tupdating_derived = true;\n\tconst value = execute_signal_fn(signal);\n\tupdating_derived = previous_updating_derived;\n\tconst status =\n\t\tcurrent_skip_consumer || (current_effect === null && (signal.f & UNOWNED) !== 0)\n\t\t\t? DIRTY\n\t\t\t: CLEAN;\n\tset_signal_status(signal, status);\n\tconst equals = /** @type {import('./types.js').EqualsFunctions} */ (signal.e);\n\tif (!equals(value, signal.v)) {\n\t\tsignal.v = value;\n\t\tmark_signal_consumers(signal, DIRTY, force_schedule);\n\n\t\t// @ts-expect-error\n\t\tif (DEV && signal.inspect && force_schedule) {\n\t\t\tfor (const fn of /** @type {import('./types.js').SignalDebug} */ (signal).inspect) fn();\n\t\t}\n\t}\n}\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {import('./types.js').Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {import('./types.js').StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\t/** @type {import('./types.js').StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\tconst is_new = entry === undefined;\n\n\tif (is_new) {\n\t\tentry = {\n\t\t\tstore: null,\n\t\t\tlast_value: null,\n\t\t\tvalue: mutable_source(UNINITIALIZED),\n\t\t\tunsubscribe: EMPTY_FUNC\n\t\t};\n\t\t// TODO: can we remove this code? it was refactored out when we split up source/comptued signals\n\t\t// push_destroy_fn(entry.value, () => {\n\t\t// \t/** @type {import('./types.js').StoreReferencesContainer['']} */ (entry).last_value =\n\t\t// \t\t/** @type {import('./types.js').StoreReferencesContainer['']} */ (entry).value.value;\n\t\t// });\n\t\tstores[store_name] = entry;\n\t}\n\n\tif (is_new || entry.store !== store) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\t\tentry.unsubscribe = connect_store_to_signal(store, entry.value);\n\t}\n\n\tconst value = get(entry.value);\n\t// This could happen if the store was cleaned up because the component was destroyed and there's a leak on the user side.\n\t// In that case we don't want to fail with a cryptic Symbol error, but rather return the last value we got.\n\treturn value === UNINITIALIZED ? entry.last_value : value;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Store<V> | null | undefined} store\n * @param {import('./types.js').SourceSignal<V>} source\n */\nfunction connect_store_to_signal(store, source) {\n\tif (store == null) {\n\t\tset(source, undefined);\n\t\treturn EMPTY_FUNC;\n\t}\n\n\t/** @param {V} v */\n\tconst run = (v) => {\n\t\tignore_mutation_validation = true;\n\t\tset(source, v);\n\t\tignore_mutation_validation = false;\n\t};\n\treturn subscribe_to_store(store, run);\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {import('./types.js').Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @param {import('./types.js').StoreReferencesContainer} stores\n */\nexport function unsubscribe_on_destroy(stores) {\n\tonDestroy(() => {\n\t\tlet store_name;\n\t\tfor (store_name in stores) {\n\t\t\tconst ref = stores[store_name];\n\t\t\tref.unsubscribe();\n\t\t\t// TODO: can we remove this code? it was refactored out when we split up source/comptued signals\n\t\t\t// destroy_signal(ref.value);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\t// @ts-expect-error\n\tif (DEV && signal.inspect && inspect_fn) {\n\t\t/** @type {import('./types.js').SignalDebug} */ (signal).inspect.add(inspect_fn);\n\t\t// @ts-expect-error\n\t\tinspect_captured_signals.push(signal);\n\t}\n\n\tconst flags = signal.f;\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn signal.v;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current consumer signal.\n\tif (current_consumer !== null && (current_consumer.f & MANAGED) === 0 && !current_untracking) {\n\t\tconst unowned = (current_consumer.f & UNOWNED) !== 0;\n\t\tconst dependencies = current_consumer.d;\n\t\tif (\n\t\t\tcurrent_dependencies === null &&\n\t\t\tdependencies !== null &&\n\t\t\tdependencies[current_dependencies_index] === signal &&\n\t\t\t!(unowned && current_effect !== null)\n\t\t) {\n\t\t\tcurrent_dependencies_index++;\n\t\t} else if (\n\t\t\tdependencies === null ||\n\t\t\tcurrent_dependencies_index === 0 ||\n\t\t\tdependencies[current_dependencies_index - 1] !== signal\n\t\t) {\n\t\t\tif (current_dependencies === null) {\n\t\t\t\tcurrent_dependencies = [signal];\n\t\t\t} else if (signal !== current_dependencies[current_dependencies.length - 1]) {\n\t\t\t\tcurrent_dependencies.push(signal);\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tcurrent_untracked_writes !== null &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\tcurrent_untracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\tschedule_effect(current_effect, false);\n\t\t}\n\t}\n\n\tif ((flags & DERIVED) !== 0 && is_signal_dirty(signal)) {\n\t\tif (DEV) {\n\t\t\t// we want to avoid tracking indirect dependencies\n\t\t\tconst previous_inspect_fn = inspect_fn;\n\t\t\tinspect_fn = null;\n\t\t\tupdate_derived(/** @type {import('./types.js').ComputationSignal<V>} **/ (signal), false);\n\t\t\tinspect_fn = previous_inspect_fn;\n\t\t} else {\n\t\t\tupdate_derived(/** @type {import('./types.js').ComputationSignal<V>} **/ (signal), false);\n\t\t}\n\t}\n\treturn signal.v;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {V}\n */\nexport function set(signal, value) {\n\tset_signal_value(signal, value);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {void}\n */\nexport function set_sync(signal, value) {\n\tflushSync(() => set(signal, value));\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_is_signals_recorded = is_signals_recorded;\n\tvar previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tif (is_signals_recorded) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\tmutate(signal, null /* doesnt matter */);\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset_signal_value(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * Updates a store with a new value.\n * @param {import('./types.js').Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function mutate_store(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {import('./types.js').ComputationSignal} signal\n * @param {boolean} inert\n * @param {Set<import('./types.js').Block>} [visited_blocks]\n * @returns {void}\n */\nfunction mark_subtree_children_inert(signal, inert, visited_blocks) {\n\tconst references = signal.r;\n\tif (references !== null) {\n\t\tlet i;\n\t\tfor (i = 0; i < references.length; i++) {\n\t\t\tmark_subtree_inert(references[i], inert, visited_blocks);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./types.js').ComputationSignal} signal\n * @param {boolean} inert\n * @param {Set<import('./types.js').Block>} [visited_blocks]\n * @returns {void}\n */\nexport function mark_subtree_inert(signal, inert, visited_blocks = new Set()) {\n\tconst flags = signal.f;\n\tconst is_already_inert = (flags & INERT) !== 0;\n\tif (is_already_inert !== inert) {\n\t\tsignal.f ^= INERT;\n\t\tif (!inert && (flags & IS_EFFECT) !== 0 && (flags & CLEAN) === 0) {\n\t\t\tschedule_effect(/** @type {import('./types.js').EffectSignal} */ (signal), false);\n\t\t}\n\t\t// Nested if block effects\n\t\tconst block = signal.b;\n\t\tif (block !== null && !visited_blocks.has(block)) {\n\t\t\tvisited_blocks.add(block);\n\t\t\tconst type = block.t;\n\t\t\tif (type === IF_BLOCK) {\n\t\t\t\tconst condition_effect = block.e;\n\t\t\t\tif (condition_effect !== null && block !== current_block) {\n\t\t\t\t\tmark_subtree_inert(condition_effect, inert);\n\t\t\t\t}\n\t\t\t\tconst consequent_effect = block.ce;\n\t\t\t\tif (consequent_effect !== null && block.v) {\n\t\t\t\t\tmark_subtree_inert(consequent_effect, inert, visited_blocks);\n\t\t\t\t}\n\t\t\t\tconst alternate_effect = block.ae;\n\t\t\t\tif (alternate_effect !== null && !block.v) {\n\t\t\t\t\tmark_subtree_inert(alternate_effect, inert, visited_blocks);\n\t\t\t\t}\n\t\t\t} else if (type === EACH_BLOCK) {\n\t\t\t\tconst items = block.v;\n\t\t\t\tfor (let { e: each_item_effect } of items) {\n\t\t\t\t\tif (each_item_effect !== null) {\n\t\t\t\t\t\tmark_subtree_inert(each_item_effect, inert, visited_blocks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmark_subtree_children_inert(signal, inert, visited_blocks);\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {number} to_status\n * @param {boolean} force_schedule\n * @returns {void}\n */\nfunction mark_signal_consumers(signal, to_status, force_schedule) {\n\tconst runes = is_runes(signal.x);\n\tconst consumers = signal.c;\n\tif (consumers !== null) {\n\t\tconst length = consumers.length;\n\t\tlet i;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tconst consumer = consumers[i];\n\t\t\tconst flags = consumer.f;\n\t\t\tconst unowned = (flags & UNOWNED) !== 0;\n\t\t\tconst dirty = (flags & DIRTY) !== 0;\n\t\t\t// We skip any effects that are already dirty (but not unowned). Additionally, we also\n\t\t\t// skip if the consumer is the same as the current effect (except if we're not in runes or we\n\t\t\t// are in force schedule mode).\n\t\t\tif ((dirty && !unowned) || ((!force_schedule || !runes) && consumer === current_effect)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_signal_status(consumer, to_status);\n\t\t\t// If the signal is not clean, then skip over it â€“ with the exception of unowned signals that\n\t\t\t// are already dirty. Unowned signals might be dirty because they are not captured as part of an\n\t\t\t// effect.\n\t\t\tif ((flags & CLEAN) !== 0 || (dirty && unowned)) {\n\t\t\t\tif ((consumer.f & IS_EFFECT) !== 0) {\n\t\t\t\t\tschedule_effect(/** @type {import('./types.js').EffectSignal} */ (consumer), false);\n\t\t\t\t} else {\n\t\t\t\t\tmark_signal_consumers(consumer, MAYBE_DIRTY, force_schedule);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {V} value\n * @returns {void}\n */\nexport function set_signal_value(signal, value) {\n\tif (\n\t\t!current_untracking &&\n\t\t!ignore_mutation_validation &&\n\t\tcurrent_consumer !== null &&\n\t\tis_runes(signal.x) &&\n\t\t(current_consumer.f & DERIVED) !== 0\n\t) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_UNSAFE_MUTATION' +\n\t\t\t\t(DEV\n\t\t\t\t\t? \": Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. \" +\n\t\t\t\t\t\t'This can lead to unexpected errors and possibly cause infinite loops.\\n\\nIf this mutation is not meant ' +\n\t\t\t\t\t\t'to be reactive do not use the \"$state\" rune for that declaration.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\tif (\n\t\t(signal.f & SOURCE) !== 0 &&\n\t\t!(/** @type {import('./types.js').EqualsFunctions} */ (signal.e)(value, signal.v))\n\t) {\n\t\tconst component_context = signal.x;\n\t\tsignal.v = value;\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// consumers as we only allocate and assign the consumers after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the consumer\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e:\n\t\t//\n\t\t// $effect(() => x++)\n\t\t//\n\t\tif (\n\t\t\tis_runes(component_context) &&\n\t\t\tcurrent_effect !== null &&\n\t\t\tcurrent_effect.c === null &&\n\t\t\t(current_effect.f & CLEAN) !== 0\n\t\t) {\n\t\t\tif (current_dependencies !== null && current_dependencies.includes(signal)) {\n\t\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\t\tschedule_effect(current_effect, false);\n\t\t\t} else {\n\t\t\t\tif (current_untracked_writes === null) {\n\t\t\t\t\tcurrent_untracked_writes = [signal];\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_untracked_writes.push(signal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmark_signal_consumers(signal, DIRTY, true);\n\t\t// If we have afterUpdates locally on the component, but we're within a render effect\n\t\t// then we will need to manually invoke the beforeUpdate/afterUpdate logic.\n\t\t// TODO: should we put this being a is_runes check and only run it in non-runes mode?\n\t\tif (current_effect === null && current_queued_pre_and_render_effects.length === 0) {\n\t\t\tconst update_callbacks = component_context?.u;\n\t\t\tif (update_callbacks != null) {\n\t\t\t\trun_all(update_callbacks.b);\n\t\t\t\tconst managed = managed_effect(() => {\n\t\t\t\t\tdestroy_signal(managed);\n\t\t\t\t\trun_all(update_callbacks.a);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tif (DEV && signal.inspect) {\n\t\t\tif (is_batching_effect) {\n\t\t\t\tlast_inspected_signal = /** @type {import('./types.js').SignalDebug} */ (signal);\n\t\t\t} else {\n\t\t\t\tfor (const fn of /** @type {import('./types.js').SignalDebug} */ (signal).inspect) fn();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @returns {void}\n */\nexport function destroy_signal(signal) {\n\tconst teardown = /** @type {null | (() => void)} */ (signal.v);\n\tconst destroy = signal.y;\n\tconst flags = signal.f;\n\tdestroy_references(signal);\n\tremove_consumers(signal, 0, true);\n\tsignal.i =\n\t\tsignal.r =\n\t\tsignal.y =\n\t\tsignal.x =\n\t\tsignal.b =\n\t\t// @ts-expect-error - this is fine, since we're assigning to null to clear out a destroyed signal\n\t\tsignal.v =\n\t\tsignal.d =\n\t\tsignal.c =\n\t\t\tnull;\n\tset_signal_status(signal, DESTROYED);\n\tif (destroy !== null) {\n\t\tif (is_array(destroy)) {\n\t\t\trun_all(destroy);\n\t\t} else {\n\t\t\tdestroy();\n\t\t}\n\t}\n\tif (teardown !== null && (flags & IS_EFFECT) !== 0) {\n\t\tteardown();\n\t}\n}\n\n/**\n * @template V\n * @param {() => V} init\n * @returns {import('./types.js').ComputationSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(init) {\n\tconst is_unowned = current_effect === null;\n\tconst flags = is_unowned ? DERIVED | UNOWNED : DERIVED;\n\tconst signal = /** @type {import('./types.js').ComputationSignal<V>} */ (\n\t\tcreate_computation_signal(flags | CLEAN, UNINITIALIZED, current_block)\n\t);\n\tsignal.i = init;\n\tsignal.x = current_component_context;\n\tsignal.e = default_equals;\n\tif (!is_unowned) {\n\t\tpush_reference(/** @type {import('./types.js').EffectSignal} */ (current_effect), signal);\n\t}\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @returns {import('./types.js').SourceSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function source(initial_value) {\n\tconst source = create_source_signal(SOURCE | CLEAN, initial_value);\n\tsource.x = current_component_context;\n\treturn source;\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @returns {import('./types.js').SourceSignal<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value) {\n\tconst s = source(initial_value);\n\ts.e = safe_equal;\n\treturn s;\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n *\n * https://svelte-5-preview.vercel.app/docs/functions#untrack\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_untracking = current_untracking;\n\ttry {\n\t\tcurrent_untracking = true;\n\t\treturn fn();\n\t} finally {\n\t\tcurrent_untracking = previous_untracking;\n\t}\n}\n\n/**\n * @param {import('./types.js').EffectType} type\n * @param {(() => void | (() => void)) | ((b: import('./types.js').Block) => void | (() => void))} init\n * @param {boolean} sync\n * @param {null | import('./types.js').Block} block\n * @param {boolean} schedule\n * @returns {import('./types.js').EffectSignal}\n */\nfunction internal_create_effect(type, init, sync, block, schedule) {\n\tconst signal = create_computation_signal(type | DIRTY, null, block);\n\tsignal.i = init;\n\tsignal.x = current_component_context;\n\tif (current_effect !== null) {\n\t\tsignal.l = current_effect.l + 1;\n\t\tif ((type & MANAGED) === 0) {\n\t\t\tpush_reference(current_effect, signal);\n\t\t}\n\t}\n\tif (schedule) {\n\t\tschedule_effect(signal, sync);\n\t}\n\treturn signal;\n}\n\n/**\n * @returns {boolean}\n */\nexport function effect_active() {\n\treturn current_effect ? (current_effect.f & MANAGED) === 0 : false;\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function user_effect(init) {\n\tif (current_effect === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_EFFECT' +\n\t\t\t\t(DEV ? ': The Svelte $effect rune can only be used during component initialisation.' : '')\n\t\t);\n\t}\n\tconst apply_component_effect_heuristics =\n\t\tcurrent_effect.f & RENDER_EFFECT &&\n\t\tcurrent_component_context !== null &&\n\t\t!current_component_context.m;\n\tconst effect = internal_create_effect(\n\t\tEFFECT,\n\t\tinit,\n\t\tfalse,\n\t\tcurrent_block,\n\t\t!apply_component_effect_heuristics\n\t);\n\tif (apply_component_effect_heuristics) {\n\t\tlet effects = /** @type {import('./types.js').ComponentContext} */ (current_component_context)\n\t\t\t.e;\n\t\tif (effects === null) {\n\t\t\teffects = /** @type {import('./types.js').ComponentContext} */ (current_component_context).e =\n\t\t\t\t[];\n\t\t}\n\t\teffects.push(effect);\n\t}\n\treturn effect;\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {() => void}\n */\nexport function user_root_effect(init) {\n\tconst effect = managed_render_effect(init);\n\treturn () => {\n\t\tdestroy_signal(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function effect(init) {\n\treturn internal_create_effect(EFFECT, init, false, current_block, true);\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function managed_effect(init) {\n\treturn internal_create_effect(EFFECT | MANAGED, init, false, current_block, true);\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @param {boolean} sync\n * @returns {import('./types.js').EffectSignal}\n */\nexport function managed_pre_effect(init, sync) {\n\treturn internal_create_effect(PRE_EFFECT | MANAGED, init, sync, current_block, true);\n}\n\n/**\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function pre_effect(init) {\n\tif (current_effect === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_EFFECT' +\n\t\t\t\t(DEV\n\t\t\t\t\t? ': The Svelte $effect.pre rune can only be used during component initialisation.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\tconst sync = current_effect !== null && (current_effect.f & RENDER_EFFECT) !== 0;\n\treturn internal_create_effect(\n\t\tPRE_EFFECT,\n\t\t() => {\n\t\t\tconst val = init();\n\t\t\tflush_local_render_effects();\n\t\t\treturn val;\n\t\t},\n\t\tsync,\n\t\tcurrent_block,\n\t\ttrue\n\t);\n}\n\n/**\n * This effect is used to ensure binding are kept in sync. We use a pre effect to ensure we run before the\n * bindings which are in later effects. However, we don't use a pre_effect directly as we don't want to flush anything.\n *\n * @param {() => void | (() => void)} init\n * @returns {import('./types.js').EffectSignal}\n */\nexport function invalidate_effect(init) {\n\treturn internal_create_effect(PRE_EFFECT, init, true, current_block, true);\n}\n\n/**\n * @template {import('./types.js').Block} B\n * @param {(block: B) => void | (() => void)} init\n * @param {any} block\n * @param {any} managed\n * @param {any} sync\n * @returns {import('./types.js').EffectSignal}\n */\nexport function render_effect(init, block = current_block, managed = false, sync = true) {\n\tlet flags = RENDER_EFFECT;\n\tif (managed) {\n\t\tflags |= MANAGED;\n\t}\n\treturn internal_create_effect(flags, /** @type {any} */ (init), sync, block, true);\n}\n\n/**\n * @template {import('./types.js').Block} B\n * @param {(block: B) => void | (() => void)} init\n * @param {any} block\n * @param {any} sync\n * @returns {import('./types.js').EffectSignal}\n */\nexport function managed_render_effect(init, block = current_block, sync = true) {\n\tconst flags = RENDER_EFFECT | MANAGED;\n\treturn internal_create_effect(flags, /** @type {any} */ (init), sync, block, true);\n}\n\n/**\n * @template V\n * @param {import('./types.js').ComputationSignal<V>} signal\n * @param {() => void} destroy_fn\n * @returns {void}\n */\nexport function push_destroy_fn(signal, destroy_fn) {\n\tlet destroy = signal.y;\n\tif (destroy === null) {\n\t\tsignal.y = destroy_fn;\n\t} else if (is_array(destroy)) {\n\t\tdestroy.push(destroy_fn);\n\t} else {\n\t\tsignal.y = [destroy, destroy_fn];\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n/**\n * @template V\n * @param {import('./types.js').Signal<V>} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * @template V\n * @param {V | import('./types.js').Signal<V>} val\n * @returns {val is import('./types.js').Signal<V>}\n */\nexport function is_signal(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('./types.js').Signal<V>} */ (val).f) === 'number'\n\t);\n}\n\n/**\n * @template O\n * @template P\n * @param {any} val\n * @returns {val is import('./types.js').LazyProperty<O, P>}\n */\nexport function is_lazy_property(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\t/** @type {import('./types.js').LazyProperty<O, P>} */ (val).t === LAZY_PROPERTY\n\t);\n}\n\n/**\n * @template V\n * @param {unknown} val\n * @returns {val is import('./types.js').Store<V>}\n */\nexport function is_store(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('./types.js').Store<V>} */ (val).subscribe) === 'function'\n\t);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [initial]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, initial) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\n\tvar setter = get_descriptor(props, key)?.set;\n\tif (DEV && setter && runes && initial !== undefined) {\n\t\t// TODO consolidate all these random runtime errors\n\t\tthrow new Error('Cannot use fallback values with bind:');\n\t}\n\n\tvar prop_value = /** @type {V} */ (props[key]);\n\n\tif (prop_value === undefined && initial !== undefined) {\n\t\t// @ts-expect-error would need a cumbersome method overload to type this\n\t\tif ((flags & PROPS_IS_LAZY_INITIAL) !== 0) initial = initial();\n\n\t\tif (DEV && runes) {\n\t\t\tinitial = readonly(proxy(/** @type {any} */ (initial)));\n\t\t}\n\n\t\tprop_value = /** @type {V} */ (initial);\n\n\t\tif (setter) setter(prop_value);\n\t}\n\n\tvar getter = () => {\n\t\tvar value = /** @type {V} */ (props[key]);\n\t\tif (value !== undefined) initial = undefined;\n\t\treturn value === undefined ? /** @type {V} */ (initial) : value;\n\t};\n\n\t// easy mode â€” prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode â€” prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\treturn function (/** @type {V} */ value) {\n\t\t\tif (arguments.length === 1) {\n\t\t\t\t/** @type {Function} */ (setter)(value);\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly â€” the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\tif (!immutable) current_value.e = safe_equal;\n\n\treturn function (/** @type {V} */ value, mutation = false) {\n\t\tvar current = get(current_value);\n\n\t\t// legacy nonsense â€” need to ensure the source is invalidated when necessary\n\t\tif (is_signals_recorded) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tif (mutation || (immutable ? value !== current : safe_not_equal(value, current))) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, mutation ? current : value);\n\t\t\t\tget(current_value); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\treturn current;\n\t};\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\t// eslint-disable-next-line eqeqeq\n\treturn a != a\n\t\t? // eslint-disable-next-line eqeqeq\n\t\t\tb == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_equal(a, b) {\n\treturn !safe_not_equal(a, b);\n}\n\n/** @returns {Map<unknown, unknown>} */\nexport function get_or_init_context_map() {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_CONTEXT' +\n\t\t\t\t(DEV ? 'Context can only be used during component initialisation.' : '')\n\t\t);\n\t}\n\tlet context_map = component_context.c;\n\tif (context_map === null) {\n\t\tconst parent_context = get_parent_context(component_context);\n\t\tcontext_map = component_context.c = new Map(parent_context || undefined);\n\t}\n\treturn context_map;\n}\n\n/**\n * @param {import('./types.js').ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @this {any}\n * @param {Record<string, unknown>} $$props\n * @param {Event} event\n * @returns {void}\n */\nexport function bubble_event($$props, event) {\n\tvar events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[\n\t\tevent.type\n\t];\n\tvar callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];\n\tfor (var fn of callbacks) {\n\t\t// Preserve \"this\" context\n\t\tfn.call(this, event);\n\t}\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tconst value = get(signal);\n\tset_signal_value(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {import('./types.js').Signal<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\tconst value = get(signal) + d;\n\tset_signal_value(signal, value);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Under some circumstances, imports may be reactive in legacy mode. In that case,\n * they should be using `reactive_import` as part of the transformation\n * @param {() => any} fn\n */\nexport function reactive_import(fn) {\n\tconst s = source(0);\n\treturn function () {\n\t\tif (arguments.length === 1) {\n\t\t\tset(s, get(s) + 1);\n\t\t\treturn arguments[0];\n\t\t} else {\n\t\t\tget(s);\n\t\t\treturn fn();\n\t\t}\n\t};\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\tobj = { ...obj };\n\tlet key;\n\tfor (key of keys) {\n\t\tdelete obj[key];\n\t}\n\treturn obj;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V} fallback\n * @returns {V}\n */\nexport function value_or_fallback(value, fallback) {\n\treturn value === undefined ? fallback : value;\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tif (!is_ssr) {\n\t\tuser_effect(() => () => untrack(fn));\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @returns {void}\n */\nexport function push(props, runes = false) {\n\tcurrent_component_context = {\n\t\t// accessors\n\t\ta: null,\n\t\t// context\n\t\tc: null,\n\t\t// effects\n\t\te: null,\n\t\t// mounted\n\t\tm: false,\n\t\t// parent\n\t\tp: current_component_context,\n\t\t// props\n\t\ts: props,\n\t\t// runes\n\t\tr: runes,\n\t\t// update_callbacks\n\t\tu: null\n\t};\n}\n\n/**\n * @param {Record<string, any>} [accessors]\n * @returns {void}\n */\nexport function pop(accessors) {\n\tconst context_stack_item = current_component_context;\n\tif (context_stack_item !== null) {\n\t\tif (accessors !== undefined) {\n\t\t\tcontext_stack_item.a = accessors;\n\t\t}\n\t\tconst effects = context_stack_item.e;\n\t\tif (effects !== null) {\n\t\t\tcontext_stack_item.e = null;\n\t\t\tfor (let i = 0; i < effects.length; i++) {\n\t\t\t\tschedule_effect(effects[i], false);\n\t\t\t}\n\t\t}\n\t\tcurrent_component_context = context_stack_item.p;\n\t\tcontext_stack_item.m = true;\n\t}\n}\n\n/**\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nfunction deep_read(value, visited = new Set()) {\n\tif (typeof value === 'object' && value !== null && !visited.has(value)) {\n\t\tvisited.add(value);\n\t\tfor (let key in value) {\n\t\t\tdeep_read(value[key], visited);\n\t\t}\n\t\tconst proto = Object.getPrototypeOf(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\tget.call(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Like `unstate`, but recursively traverses into normal arrays/objects to find potential states in them.\n * @param {any} value\n * @param {Map<any, any>} visited\n * @returns {any}\n */\nfunction deep_unstate(value, visited = new Map()) {\n\tif (typeof value === 'object' && value !== null && !visited.has(value)) {\n\t\tconst unstated = unstate(value);\n\t\tif (unstated !== value) {\n\t\t\tvisited.set(value, unstated);\n\t\t\treturn unstated;\n\t\t}\n\n\t\tlet contains_unstated = false;\n\t\t/** @type {any} */\n\t\tconst nested_unstated = Array.isArray(value) ? [] : {};\n\t\tfor (let key in value) {\n\t\t\tconst result = deep_unstate(value[key], visited);\n\t\t\tnested_unstated[key] = result;\n\t\t\tif (result !== value[key]) {\n\t\t\t\tcontains_unstated = true;\n\t\t\t}\n\t\t}\n\n\t\tvisited.set(value, contains_unstated ? nested_unstated : value);\n\t}\n\n\treturn visited.get(value) ?? value;\n}\n\n// TODO remove in a few versions, before 5.0 at the latest\nlet warned_inspect_changed = false;\n\n/**\n * @param {() => any[]} get_value\n * @param {Function} [inspect]\n */\n// eslint-disable-next-line no-console\nexport function inspect(get_value, inspect = console.log) {\n\tlet initial = true;\n\n\tpre_effect(() => {\n\t\tconst fn = () => {\n\t\t\tconst value = get_value().map((v) => deep_unstate(v));\n\t\t\tif (value.length === 2 && typeof value[1] === 'function' && !warned_inspect_changed) {\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'$inspect() API has changed. See https://svelte-5-preview.vercel.app/docs/runes#$inspect for more information.'\n\t\t\t\t);\n\t\t\t\twarned_inspect_changed = true;\n\t\t\t}\n\t\t\tinspect(initial ? 'init' : 'update', ...value);\n\t\t};\n\n\t\tinspect_fn = fn;\n\t\tconst value = get_value();\n\t\tdeep_read(value);\n\t\tinspect_fn = null;\n\n\t\tconst signals = inspect_captured_signals.slice();\n\t\tinspect_captured_signals = [];\n\n\t\tif (initial) {\n\t\t\tfn();\n\t\t\tinitial = false;\n\t\t}\n\n\t\treturn () => {\n\t\t\tfor (const s of signals) {\n\t\t\t\ts.inspect.delete(fn);\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * @template O\n * @template P\n * @param {O} o\n * @param {P} p\n * @returns {import('./types.js').LazyProperty<O, P>}\n */\nexport function lazy_property(o, p) {\n\treturn {\n\t\to,\n\t\tp,\n\t\tt: LAZY_PROPERTY\n\t};\n}\n\n/**\n * @template V\n * @param {V} value\n * @returns {import('./types.js').UnwrappedSignal<V>}\n */\nexport function unwrap(value) {\n\tif (is_signal(value)) {\n\t\t// @ts-ignore\n\t\treturn get(value);\n\t}\n\tif (is_lazy_property(value)) {\n\t\treturn value.o[value.p];\n\t}\n\t// @ts-ignore\n\treturn value;\n}\n\nif (DEV) {\n\t/** @param {string} rune */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// @ts-ignore\n\t\t\tglobalThis[rune] = () => {\n\t\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t\tthrow new Error(`${rune} is only available inside .svelte and .svelte.js/ts files`);\n\t\t\t};\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n}\n\n/**\n * Expects a value that was wrapped with `freeze` and makes it frozen.\n * @template {import('./proxy/proxy.js').StateObject} T\n * @param {T} value\n * @returns {Readonly<Record<string | symbol, any>>}\n */\nexport function freeze(value) {\n\tif (typeof value === 'object' && value != null && !is_frozen(value)) {\n\t\t// If the object is already proxified, then unstate the value\n\t\tif (STATE_SYMBOL in value) {\n\t\t\treturn object_freeze(unstate(value));\n\t\t}\n\t\t// If the value is already read-only then just use that\n\t\tif (DEV && READONLY_SYMBOL in value) {\n\t\t\treturn value;\n\t\t}\n\t\t// Otherwise freeze the object\n\t\tobject_freeze(value);\n\t}\n\treturn value;\n}\n", "import { DEV } from 'esm-env';\nimport {\n\teffect_active,\n\tget,\n\tset,\n\tupdate,\n\tsource,\n\tupdating_derived,\n\tUNINITIALIZED,\n\tmutable_source,\n\tbatch_inspect\n} from '../runtime.js';\nimport {\n\tdefine_property,\n\tget_descriptor,\n\tget_descriptors,\n\tis_array,\n\tobject_keys\n} from '../utils.js';\n\n/** @typedef {{ s: Map<string | symbol, import('../types.js').SourceSignal<any>>; v: import('../types.js').SourceSignal<number>; a: boolean, i: boolean, p: StateObject }} Metadata */\n/** @typedef {Record<string | symbol, any> & { [STATE_SYMBOL]: Metadata }} StateObject */\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const READONLY_SYMBOL = Symbol('readonly');\n\nconst object_prototype = Object.prototype;\nconst array_prototype = Array.prototype;\nconst get_prototype_of = Object.getPrototypeOf;\nconst is_frozen = Object.isFrozen;\n\n/**\n * @template {StateObject} T\n * @param {T} value\n * @param {boolean} [immutable]\n * @returns {T}\n */\nexport function proxy(value, immutable = true) {\n\tif (typeof value === 'object' && value != null && !is_frozen(value)) {\n\t\tif (STATE_SYMBOL in value) {\n\t\t\treturn /** @type {T} */ (value[STATE_SYMBOL].p);\n\t\t}\n\n\t\tconst prototype = get_prototype_of(value);\n\n\t\t// TODO handle Map and Set as well\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tconst proxy = new Proxy(value, handler);\n\t\t\tdefine_property(value, STATE_SYMBOL, {\n\t\t\t\tvalue: init(value, proxy, immutable),\n\t\t\t\twritable: false\n\t\t\t});\n\n\t\t\t// @ts-expect-error not sure how to fix this\n\t\t\treturn proxy;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {StateObject} T\n * @param {T} value\n * @param {Map<T, Record<string | symbol, any>>} already_unwrapped\n * @returns {Record<string | symbol, any>}\n */\nfunction unwrap(value, already_unwrapped = new Map()) {\n\tif (typeof value === 'object' && value != null && !is_frozen(value) && STATE_SYMBOL in value) {\n\t\tconst unwrapped = already_unwrapped.get(value);\n\t\tif (unwrapped !== undefined) {\n\t\t\treturn unwrapped;\n\t\t}\n\t\tif (is_array(value)) {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst array = [];\n\t\t\talready_unwrapped.set(value, array);\n\t\t\tfor (const element of value) {\n\t\t\t\tarray.push(unwrap(element, already_unwrapped));\n\t\t\t}\n\t\t\treturn array;\n\t\t} else {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst obj = {};\n\t\t\tconst keys = object_keys(value);\n\t\t\tconst descriptors = get_descriptors(value);\n\t\t\talready_unwrapped.set(value, obj);\n\t\t\tfor (const key of keys) {\n\t\t\t\tif (descriptors[key].get) {\n\t\t\t\t\tdefine_property(obj, key, descriptors[key]);\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {T} */\n\t\t\t\t\tconst property = value[key];\n\t\t\t\t\tobj[key] = unwrap(property, already_unwrapped);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * @template T\n * @param {T} value\n * @returns {T}\n */\nexport function unstate(value) {\n\treturn /** @type {T} */ (unwrap(/** @type {StateObject} */ (value)));\n}\n\n/**\n * @param {StateObject} value\n * @param {StateObject} proxy\n * @param {boolean} immutable\n * @returns {Metadata}\n */\nfunction init(value, proxy, immutable) {\n\treturn {\n\t\ts: new Map(),\n\t\tv: source(0),\n\t\ta: is_array(value),\n\t\ti: immutable,\n\t\tp: proxy\n\t};\n}\n\n/** @type {ProxyHandler<StateObject>} */\nconst handler = {\n\tdefineProperty(target, prop, descriptor) {\n\t\tif (descriptor.value) {\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\t\tconst s = metadata.s.get(prop);\n\t\t\tif (s !== undefined) set(s, proxy(descriptor.value, metadata.i));\n\t\t}\n\n\t\treturn Reflect.defineProperty(target, prop, descriptor);\n\t},\n\n\tdeleteProperty(target, prop) {\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst s = metadata.s.get(prop);\n\t\tconst is_array = metadata.a;\n\t\tconst boolean = delete target[prop];\n\n\t\t// If we have mutated an array directly, and the deletion\n\t\t// was successful we will also need to update the length\n\t\t// before updating the field or the version. This is to\n\t\t// ensure any effects observing length can execute before\n\t\t// effects that listen to the fields â€“ otherwise they will\n\t\t// operate an an index that no longer exists.\n\t\tif (is_array && boolean) {\n\t\t\tconst ls = metadata.s.get('length');\n\t\t\tconst length = target.length - 1;\n\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\tset(ls, length);\n\t\t\t}\n\t\t}\n\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\n\t\tif (prop in target) update(metadata.v);\n\n\t\treturn boolean;\n\t},\n\n\tget(target, prop, receiver) {\n\t\tif (DEV && prop === READONLY_SYMBOL) {\n\t\t\treturn Reflect.get(target, READONLY_SYMBOL);\n\t\t}\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\n\t\t// if we're reading a property in a reactive context, create a source,\n\t\t// but only if it's an own property and not a prototype property\n\t\tif (\n\t\t\ts === undefined &&\n\t\t\t(effect_active() || updating_derived) &&\n\t\t\t(!(prop in target) || get_descriptor(target, prop)?.writable)\n\t\t) {\n\t\t\ts = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i));\n\t\t\tmetadata.s.set(prop, s);\n\t\t}\n\n\t\tif (s !== undefined) {\n\t\t\tconst value = get(s);\n\t\t\treturn value === UNINITIALIZED ? undefined : value;\n\t\t}\n\n\t\tif (DEV) {\n\t\t\tif (typeof target[prop] === 'function' && prop !== Symbol.iterator) {\n\t\t\t\treturn batch_inspect(target, prop, receiver);\n\t\t\t}\n\t\t}\n\t\treturn Reflect.get(target, prop, receiver);\n\t},\n\n\tgetOwnPropertyDescriptor(target, prop) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t\tif (descriptor && 'value' in descriptor) {\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\t\t\tconst s = metadata.s.get(prop);\n\n\t\t\tif (s) {\n\t\t\t\tdescriptor.value = get(s);\n\t\t\t}\n\t\t}\n\n\t\treturn descriptor;\n\t},\n\n\thas(target, prop) {\n\t\tif (DEV && prop === READONLY_SYMBOL) {\n\t\t\treturn Reflect.has(target, READONLY_SYMBOL);\n\t\t}\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn true;\n\t\t}\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst has = Reflect.has(target, prop);\n\n\t\tlet s = metadata.s.get(prop);\n\t\tif (s !== undefined || (effect_active() && (!has || get_descriptor(target, prop)?.writable))) {\n\t\t\tif (s === undefined) {\n\t\t\t\ts = (metadata.i ? source : mutable_source)(\n\t\t\t\t\thas ? proxy(target[prop], metadata.i) : UNINITIALIZED\n\t\t\t\t);\n\t\t\t\tmetadata.s.set(prop, s);\n\t\t\t}\n\t\t\tconst value = get(s);\n\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t},\n\n\tset(target, prop, value) {\n\t\tif (DEV && prop === READONLY_SYMBOL) {\n\t\t\ttarget[READONLY_SYMBOL] = value;\n\t\t\treturn true;\n\t\t}\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst s = metadata.s.get(prop);\n\t\tif (s !== undefined) set(s, proxy(value, metadata.i));\n\t\tconst is_array = metadata.a;\n\t\tconst not_has = !(prop in target);\n\n\t\tif (is_array && prop === 'length') {\n\t\t\tfor (let i = value; i < target.length; i += 1) {\n\t\t\t\tconst s = metadata.s.get(i + '');\n\t\t\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\t\t\t}\n\t\t}\n\t\tif (not_has) {\n\t\t\tupdate(metadata.v);\n\t\t}\n\t\t// @ts-ignore\n\t\ttarget[prop] = value;\n\n\t\t// If we have mutated an array directly, we might need to\n\t\t// signal that length has also changed too.\n\t\tif (is_array && not_has) {\n\t\t\tconst ls = metadata.s.get('length');\n\t\t\tconst length = target.length;\n\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\tset(ls, length);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\townKeys(target) {\n\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\tget(metadata.v);\n\t\treturn Reflect.ownKeys(target);\n\t}\n};\n\n/** @param {any} object */\nexport function observe(object) {\n\tconst metadata = object[STATE_SYMBOL];\n\tif (metadata) get(metadata.v);\n}\n\nif (DEV) {\n\thandler.setPrototypeOf = () => {\n\t\tthrow new Error('Cannot set prototype of $state object');\n\t};\n}\n\nexport { readonly } from './readonly.js';\n", "import { EACH_INDEX_REACTIVE } from '../../constants.js';\nimport { source, untrack } from './runtime.js';\nimport { is_array } from './utils.js';\n\n/** regex of all html void element names */\nconst void_element_names =\n\t/^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\n\n/** @param {string} tag */\nfunction is_void(tag) {\n\treturn void_element_names.test(tag) || tag.toLowerCase() === '!doctype';\n}\n\n/**\n * @param {any} store\n * @param {string} name\n */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\n/**\n * @param {() => any} component_fn\n * @returns {any}\n */\nexport function validate_dynamic_component(component_fn) {\n\tconst error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n\ttry {\n\t\tconst instance = component_fn();\n\t\tif (instance !== undefined && typeof instance !== 'object') {\n\t\t\tthrow new Error(error_message);\n\t\t}\n\t\treturn instance;\n\t} catch (err) {\n\t\tconst { message } = /** @type {Error} */ (err);\n\t\tif (typeof message === 'string' && message.indexOf('is not a function') !== -1) {\n\t\t\tthrow new Error(error_message);\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n/**\n * @param {() => string} tag_fn\n * @returns {void}\n */\nexport function validate_void_dynamic_element(tag_fn) {\n\tconst tag = tag_fn();\n\tif (tag && is_void(tag)) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n\t}\n}\n\n/** @param {() => unknown} tag_fn */\nexport function validate_dynamic_element_tag(tag_fn) {\n\tconst tag = tag_fn();\n\tconst is_string = typeof tag === 'string';\n\tif (tag && !is_string) {\n\t\tthrow new Error('<svelte:element> expects \"this\" attribute to be a string.');\n\t}\n}\n\n/**\n * @param {() => any} collection\n * @param {(item: any, index: number) => string} key_fn\n * @returns {void}\n */\nexport function validate_each_keys(collection, key_fn) {\n\tconst keys = new Map();\n\tconst maybe_array = untrack(() => collection());\n\tconst array = is_array(maybe_array)\n\t\t? maybe_array\n\t\t: maybe_array == null\n\t\t\t? []\n\t\t\t: Array.from(maybe_array);\n\tconst length = array.length;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst key = key_fn(array[i], i);\n\t\tif (keys.has(key)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} with value '${array[i]}' are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n\n/**\n * @param {number} timeout\n * @returns {() => void}\n * */\nexport function loop_guard(timeout) {\n\tconst start = Date.now();\n\treturn () => {\n\t\tif (Date.now() - start > timeout) {\n\t\t\tthrow new Error('Infinite loop detected');\n\t\t}\n\t};\n}\n\nconst snippet_symbol = Symbol.for('svelte.snippet');\n\n/**\n * @param {any} fn\n */\nexport function add_snippet_symbol(fn) {\n\tfn[snippet_symbol] = true;\n\treturn fn;\n}\n\n/**\n * Validate that the function handed to `{@render ...}` is a snippet function, and not some other kind of function.\n * @param {any} snippet_fn\n */\nexport function validate_snippet(snippet_fn) {\n\tif (snippet_fn[snippet_symbol] !== true) {\n\t\tthrow new Error(\n\t\t\t'The argument to `{@render ...}` must be a snippet function, not a component or some other kind of function. ' +\n\t\t\t\t'If you want to dynamically render one snippet or another, use `$derived` and pass its result to `{@render ...}`.'\n\t\t);\n\t}\n\treturn snippet_fn;\n}\n\n/**\n * Validate that the function behind `<Component />` isn't a snippet.\n * @param {any} component_fn\n */\nexport function validate_component(component_fn) {\n\tif (component_fn?.[snippet_symbol] === true) {\n\t\tthrow new Error('A snippet must be rendered with `{@render ...}`');\n\t}\n\treturn component_fn;\n}\n"],
  "mappings": "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",
  "names": ["proxy", "prop", "prop", "init", "current_block", "effect", "source", "get", "inspect", "value", "is_frozen", "proxy", "handler", "unwrap", "prop", "is_array", "s", "handler"]
}
